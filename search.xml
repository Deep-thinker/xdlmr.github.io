<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2018/08/01/linux-chang-yong-ming-ling/"/>
      <url>/2018/08/01/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Linux常用的一些基本命令。</p><ol><li>查看系统版本：<pre><code>cat /etc/redhat-release 或 cat /etc/issue</code></pre></li><li>删除文件： <pre><code>rm -f /var/log/httpd/access.log</code></pre><a id="more"></a> 将会强制删除/var/log/httpd/access.log这个文件。</li><li>删除文件夹及文件夹下的所有子内容：<pre><code>rm -rf /var/log/httpd/access</code></pre> 将会删除/var/log/httpd/access目录以及其下所有文件、文件夹</li><li>修改IP地址：<pre><code>vi /etc/sysconfig/network-scripts</code></pre></li><li>查看Linux启动的服务<pre><code>chkconfig --list 查询出所有当前运行的服务</code></pre></li><li>如果只是想当前的设置状态有效，在系统重启动后即不生效的话，可以用如下命令停止服务<pre><code>service sshd stop</code></pre></li><li>移动文件夹到另一个文件夹(一般也用于文件或文件夹改名)<pre><code>mv 文件夹/* 新文件夹/</code></pre></li><li>新建文件<pre><code>touch a.txt</code></pre></li><li>查看某个命令的含义<pre><code>man ls</code></pre></li><li>查看命令的说明文档<pre><code>info ls</code></pre></li><li>查看系统运行的进程<pre><code>ps aux</code></pre></li><li>查看当前用户UID，用户id<pre><code>id</code></pre></li><li>查看当前用户GID，用户所属组<pre><code>groups</code></pre></li><li>查看当前在线用户<pre><code>who</code></pre></li><li>快速切换到root用户<pre><code>su</code></pre></li><li>查看当前目录下的文件，包括隐藏文件或文件夹<pre><code>ls -la</code></pre>隐藏文件的文件名以 . 开始</li><li>查看文件内容<pre><code>cat a.txt：查看文件全部内容head -n a.txt：查看文件前n行内容，默认前10行tail -n a.txt: 查看文件后n行内容，默认后10行，一般用于查看日志文件</code></pre></li><li>修改文件权限<pre><code>chmod 777 a.txt</code></pre>修改整个文件夹目录及目录下所有文件权限:<pre><code>chmod -R 777 文件目录名/</code></pre></li><li>查看linux系统的默认编码和支持的其他编码<pre><code>echo $LANG     //查看系统当前语系locale         //查看当前系统的语言环境locale -a      //查看系统支持的所有语言</code></pre></li><li>搜索文件<br>· locate：从后台数据库 /var/lib/mlocate 中进行搜索，速度很快，但无法搜索新建的文件。强制更新后台数据库 update.只能按照文件名搜索。<br>· whereis: 只能搜索命令。即搜索命令的命令<br>· which：搜索命令的命令<br>· find /home -name aaa.txt。在系统中搜索指定文件。<pre><code>```    -name 严格按照大小写查找    -iname 不区分大小写查找```</code></pre>· grep: grep “char” aaa.txt。在文件中搜索指定字符串。<br>· grep -v “char” aaa.txt。在文件中搜索不包含指定字符串char的字符串。(-v为取反)<br>· man: 查看命令的帮助文档<br>· whatis:查看命令的帮助级别 == man -f<br>· passwd：修改密码<br>· apropos：列出与命令相关帮助文档的所有信息 ==man -k</li><li>压缩文件<br>· zip<pre><code>压缩文件： zip a.zip a压缩文件夹： zip -r a.zip a解压文件：unzip a.zip</code></pre>· gz<pre><code>压缩源文件为原文件名.gz,并且源文件消失：gzip a压缩为.gz格式，源文件保留：gzip -c a &gt; a.gz压缩目录下的所有子文件，但是不能压缩目录：gzip -r 目录解压缩文件：gzip -d a.gz解压缩文件：gunzip a.gz解压缩目录下的文件：gunzip -r 目录</code></pre>· bz2<pre><code>压缩为.bz2格式，不保留源文件：bzip2 源文件压缩之后保留源文件：bzip2 -k 源文件** 注意：bzip2命令不能压缩目录 **解压缩，-k保留压缩文件：bzip2 -d 压缩文件解压缩，-k保留压缩文件：bunzip2 压缩文件</code></pre>· tar<pre><code>打包命令：tar -cvf a.tar a解打包命令：tar -xvf a.tar</code></pre>· tar.gz 打包并压缩<pre><code>压缩为.tar.gz格式：tar -zcvf a.tar.gz 源文件解压缩：tar -zxvf a.tar.gz</code></pre>· tar.bz2<pre><code>压缩为.tar.bz2格式：tar -jcvf a.tar.bz2 源文件解压缩：tar -jxvf a.tar.bz2指定位置的解压缩：tar - jxvf a.tar.bz2 -C /temp/仅查看压缩文件：tar -ztvf a.tar.gz</code></pre></li><li>关机(shutdown对服务器最安全)<pre><code>shutdown -h 12:00 &amp; 关机并将命令放在后台运行shutdown -c 取消前一个关机命令halt 关机poweroff 关机init 0 关机</code></pre></li><li>重启<pre><code>shutdown -r 重启rebootinit 6</code></pre></li><li>查询系统运行级别<pre><code>runlevelcat /etc/inittab</code></pre></li><li>退出登录<pre><code>logout</code></pre></li><li>查询系统中已经挂载好的设备：<pre><code>mount</code></pre></li><li>Linux默认不支持NTFS文件系统。<br>支持的条件为安装 ntfs-3g.</li><li>查看用户登录信息<pre><code>w：能看到用户登录情况及内存使用情况who：只能看到用户登录情况last:查看系统中所有用户登录信息lastlog:查看所有用户的最后一次登录信息</code></pre></li><li>查看系统中所有的命令别名<pre><code>alias</code></pre></li><li>历史命令<pre><code>查看历史命令: history清空历史命令: history -c把缓存中的历史命令写入历史命令保存文件 ~/.bash_history：history -w修改历史命令保存条数： vi /etc/profile   HISTSIZE</code></pre></li><li>查看当前日期：<pre><code>date</code></pre></li><li>查看进程树：<pre><code>pstree</code></pre></li><li>Linux安装第三方插件来支持中文显示：zhcon</li></ol><p>目前就先这么多，等待以后补充。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css弹性布局-flex布局</title>
      <link href="/2018/03/24/css-dan-xing-bu-ju-flex-bu-ju/"/>
      <url>/2018/03/24/css-dan-xing-bu-ju-flex-bu-ju/</url>
      
        <content type="html"><![CDATA[<p>本文介绍CSS3新增的布局方式，flex弹性布局，便于页面布局及项目。</p><h2 id="传统的css布局"><a href="#传统的css布局" class="headerlink" title="传统的css布局"></a>传统的css布局</h2><p>我们知道传统的css定位比较麻烦，比如垂直居中，比较难实现，但是问题比较多,很难实现自适应。<br><a id="more"></a></p><div class="oldcenter"><div class="oldcenter-div">居中</div></div><p>代码：</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"oldcenter"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"oldcenter-div"</span><span class="token operator">></span>居中<span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.oldcenter<span class="token punctuation">{</span>    border: 1px solid <span class="token comment" spellcheck="true">#D53419;</span>    background-color: <span class="token comment" spellcheck="true">#50E9EE;</span>    width: 250px<span class="token punctuation">;</span>    height: 250px<span class="token punctuation">;</span>    position: relative<span class="token punctuation">;</span><span class="token punctuation">}</span>.oldcenter-div <span class="token punctuation">{</span>    width: 50px<span class="token punctuation">;</span>    height: 50px<span class="token punctuation">;</span>    background-color: <span class="token comment" spellcheck="true">#DF6A41;</span>    margin: 0 auto<span class="token punctuation">;</span>            //左右居中    margin-top: 50%<span class="token punctuation">;</span>        //外边框距离父元素高度顶部框线50%    bottom: 25px<span class="token punctuation">;</span>            //上移自身高度的一半 50/2 <span class="token operator">=</span> 25px    position: relative<span class="token punctuation">;</span>        //设置为相对父元素定位<span class="token punctuation">}</span></code></pre><p>上面的代码可以实现居中，原理是先让子div向下移动其父元素50%的高度，再向上移动自身高度50px的一半,即25px;实现了垂直居中。代码非常冗余。</p><p>而且，如果是动态添加的列表元素，居中更麻烦</p><div class="oldcenter"><ul class="old-ul"><li>列表1</li><li>列表2</li><li>列表3</li><li>列表4</li><li>列表5</li></ul></div><p>代码：</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"oldcenter"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>ul class<span class="token operator">=</span><span class="token string">"old-ul"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表1<span class="token operator">&lt;</span>/li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表2<span class="token operator">&lt;</span>/li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表3<span class="token operator">&lt;</span>/li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表4<span class="token operator">&lt;</span>/li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表5<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>/ul<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.oldcenter<span class="token punctuation">{</span>    border: 1px solid <span class="token comment" spellcheck="true">#D53419;</span>    background-color: <span class="token comment" spellcheck="true">#50E9EE;</span>    width: 250px<span class="token punctuation">;</span>    height: 250px<span class="token punctuation">;</span>    position: relative<span class="token punctuation">;</span><span class="token punctuation">}</span>.old-ul<span class="token punctuation">{</span>    margin-top: 0px<span class="token punctuation">;</span>    height: 250px<span class="token punctuation">;</span><span class="token punctuation">}</span>.old-ul<span class="token operator">></span>li<span class="token punctuation">{</span>    height: 50px<span class="token punctuation">;</span>    line-height: 50px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个列表样式看似简单，但是如果列表中的内容是动态添加的呢？我们应该怎样设置每一个列表项的高度和行高？不可能每添加一次就改一次css代码，是不是非常的不方便。</p><p>传统的布局需要依赖于display,position,float等属性，样式调起来很不容易,所以需要改进。</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>2009年，W3C组织提出了一种新的布局方式–弹性布局，即flex布局。这种布局用少量、简单的代码，可以实现页面的响应式布局。并且如今已经得到除IE9-以外的所有浏览器的支持，完全不影响使用。</p><h3 id="初识flex"><a href="#初识flex" class="headerlink" title="初识flex"></a>初识flex</h3><p>我们先来认识一下flex，看看实现传统布局中的垂直居中是否方便。</p><div class="newcenter"><br>    <div class="newcenter-div">flex居中</div><br></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"newcenter"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"newcenter-div"</span><span class="token operator">></span>flex居中<span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.newcenter<span class="token punctuation">{</span>    width: 250px<span class="token punctuation">;</span>    height: 250px<span class="token punctuation">;</span>    border: 1px solid <span class="token comment" spellcheck="true">#D53419;</span>    background-color: <span class="token comment" spellcheck="true">#50E9EE;</span>    display: flex<span class="token punctuation">;</span>            //声明为flex布局    justify-content: center<span class="token punctuation">;</span>//水平方向左右居中    align-items: center<span class="token punctuation">;</span>    //垂直方向上下居中<span class="token punctuation">}</span>.newcenter-div<span class="token punctuation">{</span>    width: 50px<span class="token punctuation">;</span>    height: 50px<span class="token punctuation">;</span>    background-color: <span class="token comment" spellcheck="true">#DF6A41;</span><span class="token punctuation">}</span></code></pre><p>是不是觉得简单易懂，而且用起来也比较方便。</p><h3 id="flex基本概念"><a href="#flex基本概念" class="headerlink" title="flex基本概念"></a>flex基本概念</h3><p>将元素的display属性设置为flex后，该元素就成为了”flex容器”,之后的操作类似于在容器中操作，它的子元素都是容器中的部分。</p><h3 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h3><p>flex容器有6个属性</p><p><strong> 为了减少重复代码，且方便读者看懂，该标题(flex容器属性)下的所有代码的css均基于以下两个class属性 </strong></p><pre class=" language-bash"><code class="language-bash">.parent-container<span class="token punctuation">{</span>    width: 400px<span class="token punctuation">;</span>    height: 300px<span class="token punctuation">;</span>    border: 1px solid <span class="token comment" spellcheck="true">#D53419;</span>    background-color: <span class="token comment" spellcheck="true">#50E9EE;</span><span class="token punctuation">}</span>.parent-container<span class="token operator">></span>p<span class="token punctuation">{</span>    width: 50px<span class="token punctuation">;</span>    height: 30px<span class="token punctuation">;</span>    border: 1px solid <span class="token comment" spellcheck="true">#2548E7;</span>    background-color: <span class="token comment" spellcheck="true">#dbc21d;</span>    margin: 5px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>该属性用来定义，子元素的排列方向.</p><table><thead><tr><th>序号</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>row</td><td>水平方向，从左往右依次排列(默认值)</td></tr><tr><td>2</td><td>row-reverse</td><td>水平方向，从右往左依次排列</td></tr><tr><td>3</td><td>column</td><td>垂直方向，从上往下依次排列</td></tr><tr><td>4</td><td>column-reverse</td><td>垂直方向，从下往上依次排列</td></tr></tbody></table><p>1.row</p><div class="parent-container container-row"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-row"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-row<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-direction: row<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.row-reverse</p><div class="parent-container container-rowreverse"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-rowreverse"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-rowreverse<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-direction: row-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3.column</p><div class="parent-container container-column"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-column"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-column<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-direction: column<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>4.column-reverse</p><div class="parent-container container-columnreverse"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-columnreverse"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-columnreverse<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-direction: column-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>该属性用来定义，如果子元素一排排不下，那么它的换行情况.</p><table><thead><tr><th>序号</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>nowrap</td><td>表示不换行(默认值)</td></tr><tr><td>2</td><td>wrap</td><td>换行</td></tr><tr><td>3</td><td>wrap-reverse</td><td>换行，并且反向排列</td></tr></tbody></table><p>1.nowrap</p><div class="parent-container container-nowrap"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-nowrap"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex8<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex9<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex10<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex11<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-nowrap<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: nowrap<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.wrap</p><div class="parent-container container-wrap"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-wrap"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex8<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex9<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex10<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex11<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-wrap<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3.wrap-reverse</p><div class="parent-container container-wrapreverse"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-wrapreverse"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex6<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex7<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex8<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex9<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex10<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex11<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-wrapreverse<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>该属性是flex-direction属性和flex-wrap属性的结合，即flex-direction属性和flex-wrap属性的简写形式,这里就不再说明.</p><pre class=" language-bash"><code class="language-bash">.container<span class="token punctuation">{</span>    flex-flow: flex-direction <span class="token operator">||</span> flex-wrap<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>该属性用来定义，元素在水平方向上的对齐方式.</p><table><thead><tr><th>序号</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>flex-start</td><td>靠左对齐(默认值)</td></tr><tr><td>2</td><td>flex-end</td><td>靠右对齐</td></tr><tr><td>3</td><td>center</td><td>水平居中对齐</td></tr><tr><td>4</td><td>space-between</td><td>两端对齐，子元素之间间隔相等，两端无间隔</td></tr><tr><td>5</td><td>space-around</td><td>平均对齐，子元素两侧间隔相等，且不重叠</td></tr></tbody></table><p>1.flex-start</p><div class="parent-container container-justify-flexstart"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-justify-flexstart"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-justify-flexstart<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    justify-content: flex-start<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.flex-end</p><div class="parent-container container-justify-flexend"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-justify-flexend"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-justify-flexend<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    justify-content: flex-end<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3.center</p><div class="parent-container container-justify-center"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-justify-center"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-justify-center<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    justify-content: center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>4.space-between</p><div class="parent-container container-justify-spacebetween"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-justify-spacebetween"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-justify-spacebetween<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    justify-content: space-between<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>5.space-around</p><div class="parent-container container-justify-spacearound"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-justify-spacearound"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-justify-spacearound<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    justify-content: space-around<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>该属性用来定义，元素在垂直方向上的对齐方式.</p><table><thead><tr><th>序号</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>flex-start</td><td>顶部对齐(默认值)</td></tr><tr><td>2</td><td>flex-end</td><td>底部对齐</td></tr><tr><td>3</td><td>center</td><td>垂直居中对齐</td></tr><tr><td>4</td><td>baseline</td><td>子元素第一行文字的基线对齐</td></tr><tr><td>5</td><td>stretch</td><td>占满父元素整个垂直方向的高度,即高度与父元素相同(项目未设置高度或设为auto的情况下生效)(默认值)</td></tr></tbody></table><p>1.flex-start</p><div class="parent-container container-aItems-flexstart"><p style="height: 80px">flex1</p><p style="height: 40px">flex2</p><p style="height: 120px">flex3</p><p style="height: 100px">flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aItems-flexstart"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 80px"</span><span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 40px"</span><span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 120px"</span><span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 100px"</span><span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aItems-flexstart<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    align-items: flex-start<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.flex-end</p><div class="parent-container container-aItems-flexend"><p style="height: 80px">flex1</p><p style="height: 40px">flex2</p><p style="height: 120px">flex3</p><p style="height: 100px">flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aItems-flexend"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 80px"</span><span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 40px"</span><span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 120px"</span><span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 100px"</span><span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aItems-flexend<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    align-items: flex-end<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3.center</p><div class="parent-container container-aItems-center"><p style="height: 80px">flex1</p><p style="height: 40px">flex2</p><p style="height: 120px">flex3</p><p style="height: 100px">flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aItems-center"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 80px"</span><span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 40px"</span><span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 120px"</span><span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 100px"</span><span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aItems-center<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    align-items: center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>4.baseline</p><div class="parent-container container-aItems-baseline"><p style="height: 80px;font-size: 20px">flex1</p><p style="height: 40px;font-size: 14px">flex2</p><p style="height: 120px;font-size: 22px">flex3</p><p style="height: 100px;font-size: 25px">flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aItems-baseline"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 80px;font-size: 20px"</span><span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 40px;font-size: 14px"</span><span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 120px;font-size: 22px"</span><span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 100px;font-size: 25px"</span><span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aItems-baseline<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    align-items: baseline<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>5.stretch</p><div class="parent-container container-aItems-stretch"><p style="height: initial;">flex1</p><p style="height: initial;">flex2</p><p style="height: 50px;">flex3</p><p style="height: 150px;">flex4</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aItems-stretch"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: initial;"</span><span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: initial;"</span><span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 50px;"</span><span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"height: 150px;"</span><span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aItems-stretch<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    align-items: stretch<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>该属性用来定义，多排子元素在垂直方向上每一排之间的对齐方式.</p><p><strong> 该属性必须在具有多排子元素的父元素中才能生效，即必须有 flex-wrap: wrap; 或 flex-wrap: wrap-reverse;且父元素中有多个子元素，一排放不下的情况下才有效果. </strong></p><table><thead><tr><th>序号</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>flex-start</td><td>垂直方向上，排之间靠近顶部对齐</td></tr><tr><td>2</td><td>flex-end</td><td>垂直方向上，排之间靠近底部对齐</td></tr><tr><td>3</td><td>center</td><td>垂直方向上，排之间居中对齐</td></tr><tr><td>4</td><td>space-between</td><td>垂直方向上，第一排与最后一排上下两端紧靠父元素，排之间的间隔平分</td></tr><tr><td>5</td><td>space-around</td><td>垂直方向上平均对齐，排之间两侧间隔相等，且不重叠</td></tr><tr><td>6</td><td>stretch</td><td>所有排占满父元素整个垂直方向的高度(默认值)</td></tr></tbody></table><p>1.flex-start</p><div class="parent-container container-aContent-flexstart"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p><p>flex12</p><p>flex13</p><p>flex14</p><p>flex15</p><p>flex16</p><p>flex17</p><p>flex18</p><p>flex19</p><p>flex20</p><p>flex21</p><p>flex22</p><p>flex23</p><p>flex24</p><p>flex25</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aContent-flexstart"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    ···            //多个p元素    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex23<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex24<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex25<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aContent-flexstart<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: flex-start<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.flex-end</p><div class="parent-container container-aContent-flexend"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p><p>flex12</p><p>flex13</p><p>flex14</p><p>flex15</p><p>flex16</p><p>flex17</p><p>flex18</p><p>flex19</p><p>flex20</p><p>flex21</p><p>flex22</p><p>flex23</p><p>flex24</p><p>flex25</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aContent-flexend"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    ···            //多个p元素    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex23<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex24<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex25<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aContent-flexend<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: flex-end<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3.center</p><div class="parent-container container-aContent-center"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p><p>flex12</p><p>flex13</p><p>flex14</p><p>flex15</p><p>flex16</p><p>flex17</p><p>flex18</p><p>flex19</p><p>flex20</p><p>flex21</p><p>flex22</p><p>flex23</p><p>flex24</p><p>flex25</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aContent-center"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    ···            //多个p元素    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex23<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex24<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex25<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aContent-center<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>4.space-between</p><div class="parent-container container-aContent-spacebetween"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p><p>flex12</p><p>flex13</p><p>flex14</p><p>flex15</p><p>flex16</p><p>flex17</p><p>flex18</p><p>flex19</p><p>flex20</p><p>flex21</p><p>flex22</p><p>flex23</p><p>flex24</p><p>flex25</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aContent-spacebetween"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    ···            //多个p元素    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex23<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex24<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex25<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aContent-spacebetween<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: space-between<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>5.space-around</p><div class="parent-container container-aContent-spacearound"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p><p>flex12</p><p>flex13</p><p>flex14</p><p>flex15</p><p>flex16</p><p>flex17</p><p>flex18</p><p>flex19</p><p>flex20</p><p>flex21</p><p>flex22</p><p>flex23</p><p>flex24</p><p>flex25</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aContent-spacearound"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    ···            //多个p元素    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex23<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex24<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex25<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aContent-spacearound<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: space-around<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>6.stretch</p><div class="parent-container container-aContent-stretch"><p>flex1</p><p>flex2</p><p>flex3</p><p>flex4</p><p>flex5</p><p>flex6</p><p>flex7</p><p>flex8</p><p>flex9</p><p>flex10</p><p>flex11</p><p>flex12</p><p>flex13</p><p>flex14</p><p>flex15</p><p>flex16</p><p>flex17</p><p>flex18</p><p>flex19</p><p>flex20</p><p>flex21</p><p>flex22</p><p>flex23</p><p>flex24</p><p>flex25</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"parent-container container-aContent-stretch"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    ···            //多个p元素    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex23<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex24<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>flex25<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.container-aContent-stretch<span class="token punctuation">{</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: stretch<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="flex容器中子元素的属性"><a href="#flex容器中子元素的属性" class="headerlink" title="flex容器中子元素的属性"></a>flex容器中子元素的属性</h3><p><strong> 为了减少重复代码，且方便读者看懂，该标题(flex容器中子元素的属性)下的所有代码的css均基于以下两个class属性 </strong></p><pre class=" language-bash"><code class="language-bash">.child-container<span class="token punctuation">{</span>    border: 1px solid <span class="token comment" spellcheck="true">#D53419;</span>    background-color: <span class="token comment" spellcheck="true">#50E9EE;</span>    width: 350px<span class="token punctuation">;</span>    height: 100px<span class="token punctuation">;</span>    display: flex<span class="token punctuation">;</span><span class="token punctuation">}</span>.child-container<span class="token operator">></span>p<span class="token punctuation">{</span>    background-color: <span class="token comment" spellcheck="true">#dbc21d;</span>    height: 50px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>flex子元素具有6个相关的属性，可以将属性设置在子元素上。</p><table><thead><tr><th>序号</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>order</td><td>定义子元素的排列顺序。数值越小，排列越靠前，默认为0。</td></tr><tr><td>2</td><td>flex-grow</td><td>定义子元素的放大比例，如果存在剩余空间，也会等比例放大，默认为0。</td></tr><tr><td>3</td><td>flex-shrink</td><td>定义子元素的缩小比例，如果空间不足，该子元素将缩小，默认为1。</td></tr><tr><td>4</td><td>flex-basis</td><td>定义在分配多余空间之前，子元素占据的水平或垂直空间，默认为auto。</td></tr><tr><td>5</td><td>flex</td><td>是flex-grow, flex-shrink 和 flex-basis的简写，后两个属性可选，默认值为0 1 auto。</td></tr><tr><td>6</td><td>align-self</td><td>允许单个子元素有与其他子元素不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于默认值stretch。</td></tr></tbody></table><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序。数值越小，排列越靠前。</p><div class="child-container childorder"><p style="order: 36">flex1</p><p style="order: 18">flex2</p><p style="order: 5">flex3</p><p style="order: 9">flex4</p><p style="order: 6">flex5</p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child-container childorder"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"order: 36"</span><span class="token operator">></span>flex1<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"order: 18"</span><span class="token operator">></span>flex2<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"order: 5"</span><span class="token operator">></span>flex3<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"order: 9"</span><span class="token operator">></span>flex4<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"order: 6"</span><span class="token operator">></span>flex5<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.childorder<span class="token operator">></span>p<span class="token punctuation">{</span>    width:50px<span class="token punctuation">;</span>    margin: 5px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>如果所有子元素的flex-grow属性都为1，则它们将等分一排空间.<br>如果一个子元素的flex-grow属性为2，其他子元素都为1，则前者占据的宽度是其他子元素的2倍。<br><strong> 如果想要flex-grow样式正常执行，则不能给子元素定义宽度width！否则样式会与预想中的不同 </strong></p><div class="child-container"><p style="background-color:#ff7f50;flex-grow: 1;"></p><p style="background-color:#2bafd9;flex-grow: 2;"></p><p style="background-color:#f0e68c;flex-grow: 1;"></p><p style="background-color:#ffc0cb;flex-grow: 3;"></p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child-container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"background-color:#ff7f50;flex-grow: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"background-color:#2bafd9;flex-grow: 2;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"background-color:#f0e68c;flex-grow: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"background-color:#ffc0cb;flex-grow: 3;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>如果所有子元素的flex-shrink属性都为1，当空间不足时，所有子元素都将等比例缩小。如果一个子元素的flex-shrink属性为0，其他子元素都为1，则空间不足时，前者不缩小。</p><div class="child-container child-flexshrink"><p style="flex-shrink: 1;"></p><p style="flex-shrink: 0;"></p><p style="flex-shrink: 1;"></p><p style="flex-shrink: 1;"></p><p style="flex-shrink: 1;"></p><p style="flex-shrink: 1;"></p><p style="flex-shrink: 1;"></p><p style="flex-shrink: 1;"></p><p style="flex-shrink: 1;"></p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child-container child-flexshrink"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 0;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-shrink: 1;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.child-flexshrink<span class="token operator">></span>p<span class="token punctuation">{</span>    height: 50px<span class="token punctuation">;</span>    width: 50px<span class="token punctuation">;</span>    margin: 5px<span class="token punctuation">;</span>    background-color:<span class="token comment" spellcheck="true">#be5ad1;</span><span class="token punctuation">}</span></code></pre><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>定义在一排空间未被占满之前，子元素的width或height的值(例如100px)，定义之后，子元素将占据固定空间。</p><div class="child-container child-flexshrink"><p></p><p style="flex-basis: 100px;"></p><p></p><p></p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child-container child-flexshrink"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"flex-basis: 100px;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.child-flexshrink<span class="token operator">></span>p<span class="token punctuation">{</span>    height: 50px<span class="token punctuation">;</span>    width: 50px<span class="token punctuation">;</span>    margin: 5px<span class="token punctuation">;</span>    background-color:<span class="token comment" spellcheck="true">#be5ad1;</span><span class="token punctuation">}</span></code></pre><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><pre class=" language-bash"><code class="language-bash">.item <span class="token punctuation">{</span>  flex: none <span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token operator">&lt;</span><span class="token string">'flex-grow'</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token string">'flex-shrink'</span><span class="token operator">></span>? <span class="token operator">||</span> <span class="token operator">&lt;</span><span class="token string">'flex-basis'</span><span class="token operator">></span> <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>该属性有6个属性值</p><table><thead><tr><th>序号</th><th>属性值</th></tr></thead><tbody><tr><td>1</td><td>flex-start</td></tr><tr><td>2</td><td>flex-end</td></tr><tr><td>3</td><td>center</td></tr><tr><td>4</td><td>baseline</td></tr><tr><td>5</td><td>stretch</td></tr><tr><td>6</td><td>auto</td></tr></tbody></table><p>属性值含义可查看 <a href="#align-items">align-items</a> 与align-items属性值的含义相同(auto除外);</p><p>align-self默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch属性值。</p><div class="child-container child-alignself"><p></p><p style="align-self: flex-end;"></p><p></p><p></p></div><p>代码:</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"child-container child-alignself"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">"align-self: flex-end;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.child-alignself<span class="token operator">></span>p<span class="token punctuation">{</span>    height: 50px<span class="token punctuation">;</span>    width: 50px<span class="token punctuation">;</span>    margin: 5px<span class="token punctuation">;</span>    background-color:<span class="token comment" spellcheck="true">#be5ad1;</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>flex弹性布局的诞生，解决了传统CSS布局的很多问题，而且使用起来更加方便。</p><p>我们回到之前最开始的那个问题，如果列表是动态的话，使用flex是不是很方便？</p><pre class=" language-bash"><code class="language-bash">// html代码<span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"newlist"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>ul class<span class="token operator">=</span><span class="token string">"new-ul"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表1<span class="token operator">&lt;</span>/li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表2<span class="token operator">&lt;</span>/li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span>列表3<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>/ul<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>// css代码.newlist<span class="token punctuation">{</span>    border: 1px solid <span class="token comment" spellcheck="true">#D53419;</span>    background-color: <span class="token comment" spellcheck="true">#50E9EE;</span>    width: 250px<span class="token punctuation">;</span>    height: 250px<span class="token punctuation">;</span><span class="token punctuation">}</span>.new-ul<span class="token punctuation">{</span>    margin-top: 0px<span class="token punctuation">;</span>    height: 250px<span class="token punctuation">;</span>    display: flex<span class="token punctuation">;</span>    flex-wrap: wrap<span class="token punctuation">;</span>    align-content: space-around<span class="token punctuation">;</span><span class="token punctuation">}</span>.new-ul<span class="token operator">></span>li<span class="token punctuation">{</span>    width: 100%<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>三个列表的情况</p><div class="newlist"><ul class="new-ul"><li>列表1</li><li>列表2</li><li>列表3</li></ul></div><p>四个列表情况</p><div class="newlist"><ul class="new-ul"><li>列表1</li><li>列表2</li><li>列表3</li><li>列表4</li></ul></div><p>五个列表情况</p><div class="newlist"><ul class="new-ul"><li>列表1</li><li>列表2</li><li>列表3</li><li>列表4</li><li>列表5</li></ul></div><p>无需一直修改css文件，非常方便！</p><p>本章完~</p><script type="text/javascript" src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript" src="/js/my/flexincss.js"></script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构的相互转换</title>
      <link href="/2018/01/06/javascript-shu-ju-jie-gou-xiang-hu-zhuan-huan/"/>
      <url>/2018/01/06/javascript-shu-ju-jie-gou-xiang-hu-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>本文介绍 Map与Array,Object,JSON之间的相互转换<br><a id="more"></a></p><h2 id="Map转为Array"><a href="#Map转为Array" class="headerlink" title="Map转为Array"></a>Map转为Array</h2><p>Map转为Array,直接使用es6引入的扩展运算符(…)。</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> myMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span>.set<span class="token punctuation">(</span>true, 7<span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span>, <span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>            // Map <span class="token punctuation">{</span>true <span class="token operator">=</span><span class="token operator">></span> 7, Object <span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>console.log<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">..</span>.myMap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span> <span class="token punctuation">[</span> true, 7 <span class="token punctuation">]</span>, <span class="token punctuation">[</span> <span class="token punctuation">{</span> foo: 3 <span class="token punctuation">}</span>, <span class="token punctuation">[</span> <span class="token string">'abc'</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span></code></pre><h2 id="Array转为Map"><a href="#Array转为Map" class="headerlink" title="Array转为Map"></a>Array转为Map</h2><p>将Array转入Map构造函数，就可以转为Map。</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> myMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>true, 7<span class="token punctuation">]</span>, <span class="token punctuation">[</span><span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span>, <span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>            // Map <span class="token punctuation">{</span>true <span class="token operator">=</span><span class="token operator">></span> 7, Object <span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="Map转为Object"><a href="#Map转为Object" class="headerlink" title="Map转为Object"></a>Map转为Object</h2><p>如果所有Map的键都是字符串，它可以转为Object。</p><pre class=" language-bash"><code class="language-bash">方法:<span class="token keyword">function</span> strMapToObj<span class="token punctuation">(</span>strMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>let <span class="token punctuation">[</span>k,v<span class="token punctuation">]</span> of strMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">v</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span>使用:<span class="token keyword">let</span> myMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token string">'yes'</span>, true<span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token string">'no'</span>, false<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                // Map <span class="token punctuation">{</span><span class="token string">"yes"</span> <span class="token operator">=</span><span class="token operator">></span> true, <span class="token string">"no"</span> <span class="token operator">=</span><span class="token operator">></span> false<span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> strMapToObj<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>                // Object <span class="token punctuation">{</span>yes: true, no: false<span class="token punctuation">}</span></code></pre><h2 id="Object转为Map"><a href="#Object转为Map" class="headerlink" title="Object转为Map"></a>Object转为Map</h2><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> objToStrMap<span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> strMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>let k of Object.keys<span class="token punctuation">(</span>obj<span class="token punctuation">))</span> <span class="token punctuation">{</span>        strMap.set<span class="token punctuation">(</span>k, obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> strMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>yes: true, no: false<span class="token punctuation">}</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>                // Object <span class="token punctuation">{</span>yes: true, no: false<span class="token punctuation">}</span><span class="token keyword">let</span> myMap <span class="token operator">=</span> objToStrMap<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                // Map <span class="token punctuation">{</span><span class="token string">"yes"</span> <span class="token operator">=</span><span class="token operator">></span> true, <span class="token string">"no"</span> <span class="token operator">=</span><span class="token operator">></span> false<span class="token punctuation">}</span></code></pre><h2 id="Map转为JSON"><a href="#Map转为JSON" class="headerlink" title="Map转为JSON"></a>Map转为JSON</h2><p>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON.</p><p>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。</p><h3 id="Map转为对象JSON"><a href="#Map转为对象JSON" class="headerlink" title="Map转为对象JSON"></a>Map转为对象JSON</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> strMapToJson<span class="token punctuation">(</span>strMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>let <span class="token punctuation">[</span>k,v<span class="token punctuation">]</span> of strMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">v</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> JSON.stringify<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> myMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token string">'yes'</span>, true<span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token string">'no'</span>, false<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    // Map <span class="token punctuation">{</span><span class="token string">"yes"</span> <span class="token operator">=</span><span class="token operator">></span> true, <span class="token string">"no"</span> <span class="token operator">=</span><span class="token operator">></span> false<span class="token punctuation">}</span><span class="token keyword">let</span> objJson <span class="token operator">=</span> strMapToJson<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>objJson<span class="token punctuation">)</span><span class="token punctuation">;</span>                // <span class="token punctuation">{</span><span class="token string">"yes"</span>:true,<span class="token string">"no"</span>:false<span class="token punctuation">}</span></code></pre><h3 id="Map转为数组JSON"><a href="#Map转为数组JSON" class="headerlink" title="Map转为数组JSON"></a>Map转为数组JSON</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> mapToArrayJson<span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> JSON.stringify<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">..</span>.map<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> myMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span>.set<span class="token punctuation">(</span>true, 7<span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span>, <span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    // Map <span class="token punctuation">{</span>true <span class="token operator">=</span><span class="token operator">></span> 7, Object <span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> arrJson <span class="token operator">=</span> mapToArrayJson<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>arrJson<span class="token punctuation">)</span><span class="token punctuation">;</span>                // <span class="token punctuation">[</span><span class="token punctuation">[</span>true,7<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"foo"</span>:3<span class="token punctuation">}</span>,<span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><h2 id="JSON转为Map"><a href="#JSON转为Map" class="headerlink" title="JSON转为Map"></a>JSON转为Map</h2><p>JSON转为Map，正常情况下，所有键名都是字符串。</p><p>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。</p><h3 id="JSON键名是字符串"><a href="#JSON键名是字符串" class="headerlink" title="JSON键名是字符串"></a>JSON键名是字符串</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> jsonToStrMap<span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> JSON.parse<span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> strMap <span class="token operator">=</span> new Map<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>let k of Object.keys<span class="token punctuation">(</span>obj<span class="token punctuation">))</span> <span class="token punctuation">{</span>        strMap.set<span class="token punctuation">(</span>k, obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> strMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> strJson <span class="token operator">=</span> <span class="token string">'{"yes":true,"no":false}'</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>strJson<span class="token punctuation">)</span><span class="token punctuation">;</span>                // <span class="token punctuation">{</span><span class="token string">"yes"</span>:true,<span class="token string">"no"</span>:false<span class="token punctuation">}</span><span class="token keyword">let</span> myMap <span class="token operator">=</span> jsonToStrMap<span class="token punctuation">(</span>strJson<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    // Map <span class="token punctuation">{</span><span class="token string">"yes"</span> <span class="token operator">=</span><span class="token operator">></span> true, <span class="token string">"no"</span> <span class="token operator">=</span><span class="token operator">></span> false<span class="token punctuation">}</span></code></pre><h3 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> jsonToMap<span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new Map<span class="token punctuation">(</span>JSON.parse<span class="token punctuation">(</span>jsonStr<span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> arrJson <span class="token operator">=</span> <span class="token string">'[[true,7],[{"foo":3},["abc"]]]'</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>arrJson<span class="token punctuation">)</span><span class="token punctuation">;</span>            // <span class="token punctuation">[</span><span class="token punctuation">[</span>true,7<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"foo"</span>:3<span class="token punctuation">}</span>,<span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">let</span> myMap <span class="token operator">=</span> jsonToMap<span class="token punctuation">(</span>arrJson<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>myMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                // Map <span class="token punctuation">{</span>true <span class="token operator">=</span><span class="token operator">></span> 7, Object <span class="token punctuation">{</span>foo: 3<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>本文完！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SASS用法</title>
      <link href="/2017/12/18/sass-ji-ben-yong-fa/"/>
      <url>/2017/12/18/sass-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="SASS起源"><a href="#SASS起源" class="headerlink" title="SASS起源"></a>SASS起源</h2><p>CSS不是一种编程语言，写起来比较麻烦，而且如果要修改整体颜色风格的话，比较费事，需要改很多地方，还要一个一个地找。所以如果将一些公共元素定义为函数中的变量，就可以只修改一处，多处共同更新了。这就是”CSS预处理器”的初步提现。</p><p>CSS预处理器：CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。</p><p>常用的”CSS预处理器”有：<a href="http://sass-lang.com/" target="_blank" rel="noopener">SASS</a> , <a href="http://lesscss.org/" target="_blank" rel="noopener">LESS</a> , <a href="http://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="noopener">Stylus</a><br><a id="more"></a></p><h2 id="SASS简介"><a href="#SASS简介" class="headerlink" title="SASS简介"></a>SASS简介</h2><p>SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h3><p>SASS有两种文件后缀名：test.sass和test.scss。两个的用法都差不多，区别在于，sass语法更适用于python类不带括号和分号的程序员，scss跟我们平时写css的格式差不多。</p><pre class=" language-bash"><code class="language-bash">//后缀名为.sass的写法body  background: <span class="token comment" spellcheck="true">#eee</span>  font-size:12pxp  background: <span class="token comment" spellcheck="true">#0982c1</span>//后缀名为.scss的写法body <span class="token punctuation">{</span>  background: <span class="token comment" spellcheck="true">#eee;</span>  font-size:12px<span class="token punctuation">;</span><span class="token punctuation">}</span>p <span class="token punctuation">{</span>  background: <span class="token comment" spellcheck="true">#0982c1;</span><span class="token punctuation">}</span></code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h4><p>SASS允许使用变量来定义属性名,CSS类名,或属性值，变量的定义类似于PHP，以”$”符号开头：</p><p>定义属性值：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$red</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#f00;</span>div <span class="token punctuation">{</span>    color: <span class="token variable">$red</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义属性名：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$direction</span><span class="token keyword">:</span> <span class="token function">top</span><span class="token punctuation">;</span>div<span class="token punctuation">{</span>    border-<span class="token comment" spellcheck="true">#{$direction}: 1px solid #eee;</span><span class="token punctuation">}</span></code></pre><p>定义类名：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$direction</span><span class="token keyword">:</span> <span class="token function">top</span><span class="token punctuation">;</span>.myborder-<span class="token comment" spellcheck="true">#{$direction} {</span>    border-<span class="token comment" spellcheck="true">#{$direction}: 1px solid #eee;</span><span class="token punctuation">}</span></code></pre><h4 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h4><p>SASS设置默认变量</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$baseLineHeight</span><span class="token keyword">:</span> 1.5 <span class="token operator">!</span>default<span class="token punctuation">;</span>body<span class="token punctuation">{</span>    line-height: <span class="token variable">$baseLineHeight</span><span class="token punctuation">;</span> //line-height: 1.5<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SASS的默认变量一般用来设置默认值，然后根据需求来覆盖，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。</p><pre class=" language-bash"><code class="language-bash">//sass style//-------------------------------<span class="token variable">$baseLineHeight</span><span class="token keyword">:</span>        2<span class="token punctuation">;</span><span class="token variable">$baseLineHeight</span><span class="token keyword">:</span>        1.5 <span class="token operator">!</span>default<span class="token punctuation">;</span>body<span class="token punctuation">{</span>    line-height: <span class="token variable">$baseLineHeight</span><span class="token punctuation">;</span> //line-height: 2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="多值变量"><a href="#多值变量" class="headerlink" title="多值变量"></a>多值变量</h4><p>多值变量分为list类型和map类型，list类似于js中的数组，map类似于js中的对象。</p><ul><li>list变量</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token variable">$linkColor</span><span class="token keyword">:</span><span class="token comment" spellcheck="true">#08c #333 !default;//第一个值为默认值，第二个鼠标滑过值</span>a <span class="token punctuation">{</span>  color:nth<span class="token punctuation">(</span><span class="token variable">$linkColor</span>,1<span class="token punctuation">)</span><span class="token punctuation">;</span> //color: <span class="token comment" spellcheck="true">#08c;</span>  <span class="token operator">&amp;</span>:hover <span class="token punctuation">{</span>    color:nth<span class="token punctuation">(</span><span class="token variable">$linkColor</span>,2<span class="token punctuation">)</span><span class="token punctuation">;</span> //color: <span class="token comment" spellcheck="true">#333; </span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>map变量</li></ul><pre class=" language-bash"><code class="language-bash">// SASS<span class="token variable">$headings</span><span class="token keyword">:</span> <span class="token punctuation">(</span>h1: 2em, h2: 1.5em, h3: 1.2em<span class="token punctuation">)</span><span class="token punctuation">;</span>@each <span class="token variable">$header</span>, <span class="token variable">$size</span> <span class="token keyword">in</span> <span class="token variable">$headings</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">#{$header} {</span>    font-size: <span class="token variable">$size</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>// CSSh1 <span class="token punctuation">{</span>  font-size: 2em<span class="token punctuation">;</span> <span class="token punctuation">}</span>h2 <span class="token punctuation">{</span>  font-size: 1.5em<span class="token punctuation">;</span> <span class="token punctuation">}</span>h3 <span class="token punctuation">{</span>  font-size: 1.2em<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>SASS提供了两种类型的注释：</p><ul><li><p>单行注释 “// 注释”,只保留在SASS源文件中，编译后的CSS文件无该注释。</p></li><li><p>多行注释 “/<em> 注释 </em>/“,这种注释会保留到编译后的CSS文件里。</p></li><li><p>多行注释里还有一种, “/<em>! 注释 </em>/“,在 “/* “后面加一个感叹号 “!”,表明这是重要注释，即使是压缩模式编译，也会保留这行注释，通常用来声明版权信息。</p></li></ul><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>SASS嵌套分为两种：选择器嵌套和属性嵌套。</p><p>1.选择器嵌套</p><p>选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了sass文件的结构性和可读性.</p><p>在选择器嵌套中，可以使用&amp;表示父元素选择器.</p><pre class=" language-bash"><code class="language-bash">// SASS<span class="token comment" spellcheck="true">#top_nav{</span>  background-color:<span class="token comment" spellcheck="true">#333;</span>  li<span class="token punctuation">{</span>    float:left<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  a<span class="token punctuation">{</span>    display: block<span class="token punctuation">;</span>    padding: 0 10px<span class="token punctuation">;</span>    color: <span class="token comment" spellcheck="true">#fff;</span>    <span class="token operator">&amp;</span>:hover<span class="token punctuation">{</span>      color:<span class="token comment" spellcheck="true">#ddd;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>// CSS<span class="token comment" spellcheck="true">#top_nav{</span>  background-color:<span class="token comment" spellcheck="true">#333;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">#top_nav li{</span>  float:left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#top_nav a{</span>  display: block<span class="token punctuation">;</span>  padding: 0 10px<span class="token punctuation">;</span>  color: <span class="token comment" spellcheck="true">#fff;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#top_nav a:hover{</span>  color:<span class="token comment" spellcheck="true">#ddd;</span><span class="token punctuation">}</span></code></pre><p>2.属性嵌套</p><p><strong> 属性后面必须加上冒号 </strong></p><pre class=" language-bash"><code class="language-bash">//SASSp <span class="token punctuation">{</span>  border: <span class="token punctuation">{</span>    color: red<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>//CSSp <span class="token punctuation">{</span>  border-color: red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>SASS支持运算功能，可以对数值型的参数，变量等进行加减乘除等运算。</p><p><strong> 运算符前后请留一个空格，不然会出错。 </strong></p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$var</span><span class="token keyword">:</span> 80%<span class="token punctuation">;</span>body <span class="token punctuation">{</span>  margin: <span class="token punctuation">(</span>14px/2<span class="token punctuation">)</span><span class="token punctuation">;</span>  top: 50px + 100px<span class="token punctuation">;</span>  width: <span class="token variable">$var</span> + 10%<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="CSS重用"><a href="#CSS重用" class="headerlink" title="CSS重用"></a>CSS重用</h2><h3 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承@extend"></a>继承@extend</h3><p>SASS允许一个选择器，继承另一个选择器的样式。关键词为 “@extend”.</p><p>例：class2要继承class1的样式。</p><pre class=" language-bash"><code class="language-bash">// SASS.class1 <span class="token punctuation">{</span>  border: 1px solid <span class="token comment" spellcheck="true">#ddd;</span><span class="token punctuation">}</span>.class2 <span class="token punctuation">{</span>  @extend .class1<span class="token punctuation">;</span>  font-size: 1.2em<span class="token punctuation">;</span><span class="token punctuation">}</span>// CSS.class1 <span class="token punctuation">{</span>  border: 1px solid <span class="token comment" spellcheck="true">#ddd;</span><span class="token punctuation">}</span>.class2 <span class="token punctuation">{</span>  border: 1px solid <span class="token comment" spellcheck="true">#ddd;</span>  font-size: 1.2em<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="定义代码块-mixin-include"><a href="#定义代码块-mixin-include" class="headerlink" title="定义代码块@mixin,@include"></a>定义代码块@mixin,@include</h3><p>Mixin类似于C语言的宏，是可以重用的代码块。</p><p>mixin有两种类型：一种是不带参数的mixin，一种是带参数的mixin；</p><h4 id="不带参数mixin"><a href="#不带参数mixin" class="headerlink" title="不带参数mixin"></a>不带参数mixin</h4><pre class=" language-bash"><code class="language-bash">// SASS@mixin center-block <span class="token punctuation">{</span>  margin-left:auto<span class="token punctuation">;</span>  margin-right:auto<span class="token punctuation">;</span><span class="token punctuation">}</span>.demo <span class="token punctuation">{</span>  @include center-block<span class="token punctuation">;</span><span class="token punctuation">}</span>//CSS.demo <span class="token punctuation">{</span>  margin-left:auto<span class="token punctuation">;</span>  margin-right:auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="带参数mixin"><a href="#带参数mixin" class="headerlink" title="带参数mixin"></a>带参数mixin</h4><p>带参数的mixin，如果不指定参数，则使用默认值。</p><pre class=" language-bash"><code class="language-bash">// SASS@mixin left<span class="token punctuation">(</span><span class="token variable">$value</span><span class="token keyword">:</span> 10px<span class="token punctuation">)</span> <span class="token punctuation">{</span>  float: left<span class="token punctuation">;</span>  margin-right: <span class="token variable">$value</span><span class="token punctuation">;</span><span class="token punctuation">}</span>div1 <span class="token punctuation">{</span>  @include left<span class="token punctuation">;</span><span class="token punctuation">}</span>div2 <span class="token punctuation">{</span>  @include left<span class="token punctuation">(</span>20px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>// CSSdiv1 <span class="token punctuation">{</span>  float: left<span class="token punctuation">;</span>  margin-right: 10px<span class="token punctuation">;</span><span class="token punctuation">}</span>div2 <span class="token punctuation">{</span>  float: left<span class="token punctuation">;</span>  margin-right: 20px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="导入CSS-import"><a href="#导入CSS-import" class="headerlink" title="导入CSS @import"></a>导入CSS @import</h3><ul><li>@import命令，用来插入外部文件。<br>  @import “path/filename.scss”;</li><li>如果插入的是.css文件，则等同于css的import命令。<br>  @import “foo.css”;</li></ul><p>通过@import将b.css文件导入a.scss文件,b.css文件的内容不会被导入编译后的a.css文件中。</p><p>通过@import将c.scss文件导入a.scss文件,c.scss文件的内容将会被导入编译后的a.css文件中。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>SASS不仅有变量，运算符等用法，还有循环、判断等函数用法，使CSS更灵活。</p><h3 id="if-else判断"><a href="#if-else判断" class="headerlink" title="if,else判断"></a>if,else判断</h3><pre class=" language-bash"><code class="language-bash">p <span class="token punctuation">{</span>  @if 1 + 1 <span class="token operator">==</span> 2 <span class="token punctuation">{</span> border: 1px solid<span class="token punctuation">;</span> <span class="token punctuation">}</span>  @if 5 <span class="token operator">&lt;</span> 3 <span class="token punctuation">{</span> border: 2px dotted<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>@if lightness<span class="token punctuation">(</span><span class="token variable">$color</span><span class="token punctuation">)</span> <span class="token operator">></span> 30% <span class="token punctuation">{</span>  background-color: <span class="token comment" spellcheck="true">#000;</span><span class="token punctuation">}</span> @else <span class="token punctuation">{</span>  background-color: <span class="token comment" spellcheck="true">#fff;</span><span class="token punctuation">}</span></code></pre><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre class=" language-bash"><code class="language-bash">// SASS@for <span class="token variable">$i</span> from 1 to 3 <span class="token punctuation">{</span>  .item-<span class="token comment" spellcheck="true">#{$i} { width: 2em * $i; }</span><span class="token punctuation">}</span>// CSS.item-1 <span class="token punctuation">{</span>  width: 2em<span class="token punctuation">;</span> <span class="token punctuation">}</span>.item-2 <span class="token punctuation">{</span>  width: 4em<span class="token punctuation">;</span> <span class="token punctuation">}</span>.item-3 <span class="token punctuation">{</span>  width: 6em<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre class=" language-bash"><code class="language-bash">// SASS<span class="token variable">$i</span><span class="token keyword">:</span> 6<span class="token punctuation">;</span>@while <span class="token variable">$i</span> <span class="token operator">></span> 0 <span class="token punctuation">{</span>  .item-<span class="token comment" spellcheck="true">#{$i} { width: 2em * $i; }</span>  <span class="token variable">$i</span><span class="token keyword">:</span> <span class="token variable">$i</span> - 2<span class="token punctuation">;</span><span class="token punctuation">}</span>// CSS.item-6 <span class="token punctuation">{</span>  width: 12em<span class="token punctuation">;</span><span class="token punctuation">}</span>.item-4 <span class="token punctuation">{</span>  width: 8em<span class="token punctuation">;</span><span class="token punctuation">}</span>.item-2 <span class="token punctuation">{</span>  width: 4em<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="each循环"><a href="#each循环" class="headerlink" title="each循环"></a>each循环</h3><pre class=" language-bash"><code class="language-bash">// SASS<span class="token variable">$img</span>-list: a,b,c,d<span class="token punctuation">;</span>@each <span class="token variable">$img</span> <span class="token keyword">in</span> img-list <span class="token punctuation">{</span>  .show-<span class="token comment" spellcheck="true">#{$img} {</span>    background-image: url<span class="token punctuation">(</span><span class="token string">"/image/#{<span class="token variable">$img</span>}.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>// CSS.show-a <span class="token punctuation">{</span>  background-image: url<span class="token punctuation">(</span><span class="token string">"/image/a.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>.show-b <span class="token punctuation">{</span>  background-image: url<span class="token punctuation">(</span><span class="token string">"/image/b.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>.show-c <span class="token punctuation">{</span>  background-image: url<span class="token punctuation">(</span><span class="token string">"/image/c.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>.show-d <span class="token punctuation">{</span>  background-image: url<span class="token punctuation">(</span><span class="token string">"/image/d.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="自定义函数-function"><a href="#自定义函数-function" class="headerlink" title="自定义函数@function"></a>自定义函数@function</h3><p>SASS为用户提供了自定义编写函数的方法。</p><pre class=" language-bash"><code class="language-bash">// SASS@function multiply<span class="token punctuation">(</span><span class="token variable">$i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  @return <span class="token variable">$i</span> * 2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#navbar {</span>  font-size: multiply<span class="token punctuation">(</span>15px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>// CSS<span class="token comment" spellcheck="true">#navbar {</span>  font-size: 30px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> SASS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js容易混淆的几个函数</title>
      <link href="/2017/08/27/javascript-rong-yi-hun-yao-de-ji-ge-han-shu/"/>
      <url>/2017/08/27/javascript-rong-yi-hun-yao-de-ji-ge-han-shu/</url>
      
        <content type="html"><![CDATA[<p>今天我来为大家介绍一下Javascript中比较容易混淆的几个函数。</p><h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>在Javascript中，call和apply都是用另一个对象替换当前对象的方法。<br><a id="more"></a></p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>call方法用来调用一个对象的一个方法，以另一个对象来替换当前对象。</p><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> add<span class="token punctuation">(</span>a, b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a + b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> sub<span class="token punctuation">(</span>a, b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a - b<span class="token punctuation">;</span><span class="token punctuation">}</span>var result <span class="token operator">=</span> add.call<span class="token punctuation">(</span>sub, 8, 5<span class="token punctuation">)</span><span class="token punctuation">;</span>var result2 <span class="token operator">=</span> sub.call<span class="token punctuation">(</span>add, 8, 5<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    //13console.log<span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    //3</code></pre><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这段代码的意思就是：用add来替换sub，add.call(sub, 8, 5) == add(8,5);所以结果result为13。sub.call(add, 8, 5) == sub(8,5);所以结果result2为3.</p><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>如果你还是看不懂，那么我再来举个例子，代码如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> fn1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.a <span class="token operator">=</span> 1<span class="token punctuation">;</span>    this.b <span class="token operator">=</span> 2<span class="token punctuation">;</span>    this.add <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> this.a + this.b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> fn2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.a <span class="token operator">=</span> 3<span class="token punctuation">;</span>    this.b <span class="token operator">=</span> 4<span class="token punctuation">;</span><span class="token punctuation">}</span>var f1 <span class="token operator">=</span> new fn1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var f2 <span class="token operator">=</span> new fn2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var result <span class="token operator">=</span> f1.add.call<span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 7</code></pre><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>上边的代码，很明显 fn2 中并没有add函数，我们这里使用了继承的方法，通过继承fn1方法中的add函数，对fn2来实现add的功能。这个应该可以看得懂了吧！</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>apply方法用来调用一个对象的一个方法，以另一个对象来替换当前对象。</p><p>是不是发现apply()方法和call()方法的定义一模一样。没错，这里不是我写错了，而是它们确实用法一模一样。</p><p><strong> 唯一的区别就是，call方法的第二个参数及之后的参数可以是任意类型，而apply的第二个参数必须是数组形式。</strong></p><h4 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1"></a>例子1</h4><p>我们用上面call的例子来写一下apply方法。</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> add<span class="token punctuation">(</span>a, b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a + b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> sub<span class="token punctuation">(</span>a, b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a - b<span class="token punctuation">;</span><span class="token punctuation">}</span>var result1 <span class="token operator">=</span> add.apply<span class="token punctuation">(</span>sub, <span class="token punctuation">[</span>8, 5<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var result2 <span class="token operator">=</span> sub.apply<span class="token punctuation">(</span>add, <span class="token punctuation">[</span>8, 5<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//var result3 <span class="token operator">=</span> add.apply<span class="token punctuation">(</span>sub, 8, 5<span class="token punctuation">)</span><span class="token punctuation">;</span>//var result4 <span class="token operator">=</span> sub.apply<span class="token punctuation">(</span>add, 8, 5<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>    //13console.log<span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    //3//console.log<span class="token punctuation">(</span>result3<span class="token punctuation">)</span><span class="token punctuation">;</span>    //报错//console.log<span class="token punctuation">(</span>result4<span class="token punctuation">)</span><span class="token punctuation">;</span>    //报错</code></pre><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><p>这段代码的意思就是：用add来替换sub，add.apply(sub, [8, 5]) == add(8,5);所以结果result为13。sub.apply(add, [8, 5]) == sub(8,5);所以结果result2为3.</p><h4 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> fn1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.add <span class="token operator">=</span> function<span class="token punctuation">(</span>a,b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> a + b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> fn2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>var f1 <span class="token operator">=</span> new fn1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var f2 <span class="token operator">=</span> new fn2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var result1 <span class="token operator">=</span> f1.add<span class="token punctuation">(</span>1,2<span class="token punctuation">)</span><span class="token punctuation">;</span>var result2 <span class="token operator">=</span> f1.add.apply<span class="token punctuation">(</span>f2,<span class="token punctuation">[</span>3,4<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>    //3console.log<span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    //7</code></pre><p>上面例子中，函数fn2并没有add方法，但是我们可以通过apply函数调用fn1函数中的add方法，实现继承。</p><h2 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h2><p>在Javascript中，有这样两个用来判断数据类型的方法，typeof和instanceof。</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>typeof方法可以用来检测变量的数据类型，它有6个可能的返回值：</p><ol><li>‘string’       ———字符串类型</li><li>‘number’       ———数值类型</li><li>‘object’       ———对象类型或数组类型或null</li><li>‘boolean’      ———布尔值，true或false</li><li>‘undefined’    ———未定义或未赋值</li><li>‘function’     ———函数或方法。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>var num <span class="token operator">=</span> 123<span class="token punctuation">;</span>var s <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>var arr <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token punctuation">;</span>var obj <span class="token operator">=</span> <span class="token punctuation">{</span>name:<span class="token string">'John'</span>,sex:<span class="token string">'man'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>var bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>var nothing<span class="token punctuation">;</span>var nul <span class="token operator">=</span> null<span class="token punctuation">;</span>var fn <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>typeof str<span class="token punctuation">)</span><span class="token punctuation">;</span>    //stringconsole.log<span class="token punctuation">(</span>typeof num<span class="token punctuation">)</span><span class="token punctuation">;</span>    //numberconsole.log<span class="token punctuation">(</span>typeof s<span class="token punctuation">)</span><span class="token punctuation">;</span>        //stringconsole.log<span class="token punctuation">(</span>typeof arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    //objectconsole.log<span class="token punctuation">(</span>typeof obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    //objectconsole.log<span class="token punctuation">(</span>typeof bool<span class="token punctuation">)</span><span class="token punctuation">;</span>    //booleanconsole.log<span class="token punctuation">(</span>typeof nothing<span class="token punctuation">)</span><span class="token punctuation">;</span>//undefinedconsole.log<span class="token punctuation">(</span>typeof nul<span class="token punctuation">)</span><span class="token punctuation">;</span>    //objectconsole.log<span class="token punctuation">(</span>typeof fn<span class="token punctuation">)</span><span class="token punctuation">;</span>        //functionconsole.log<span class="token punctuation">(</span>typeof aaa<span class="token punctuation">)</span><span class="token punctuation">;</span>    //undefined</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>instanceof 方法用来检测变量的数据类型是否为要检测的收据类型，它只有2个可能的返回值：<br>true 或 false，即布尔值。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>var num <span class="token operator">=</span> 123<span class="token punctuation">;</span>var s <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var n <span class="token operator">=</span> new Number<span class="token punctuation">(</span>123<span class="token punctuation">)</span><span class="token punctuation">;</span>var obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>var arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>str instanceof String<span class="token punctuation">)</span><span class="token punctuation">;</span>    //falseconsole.log<span class="token punctuation">(</span>num instanceof Number<span class="token punctuation">)</span><span class="token punctuation">;</span>    //falseconsole.log<span class="token punctuation">(</span>s instanceof String<span class="token punctuation">)</span><span class="token punctuation">;</span>    //trueconsole.log<span class="token punctuation">(</span>n instanceof Number<span class="token punctuation">)</span><span class="token punctuation">;</span>    //trueconsole.log<span class="token punctuation">(</span>obj instanceof Object<span class="token punctuation">)</span><span class="token punctuation">;</span>    //trueconsole.log<span class="token punctuation">(</span>arr instanceof Array<span class="token punctuation">)</span><span class="token punctuation">;</span>    //true</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>从上面的代码可以看出，instanceof确实只返回一个布尔值。而且，要注意的是：<br><strong> instanceof只能用来判断对象和函数，不能用来判断字符串和数字等 </strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见前端知识点</title>
      <link href="/2017/08/08/qian-duan-chang-jian-zhi-shi-dian/"/>
      <url>/2017/08/08/qian-duan-chang-jian-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p>本文讲述了部分前端面试经常遇到的问题。<br><a id="more"></a></p><h2 id="HTML和CSS"><a href="#HTML和CSS" class="headerlink" title="HTML和CSS"></a>HTML和CSS</h2><h3 id="对WEB标准以及W3C的理解"><a href="#对WEB标准以及W3C的理解" class="headerlink" title="对WEB标准以及W3C的理解"></a>对WEB标准以及W3C的理解</h3><p>1.写代码的时候注意</p><ul><li>标签闭合</li><li>标签小写</li><li>不能随意嵌套</li></ul><p>2.提高搜索引擎搜到几率</p><p>mate中的name变量(其中keywords和description尤其重要)</p><pre class=" language-bash"><code class="language-bash">Meta name<span class="token operator">=</span><span class="token string">"Keywords"</span> Lang<span class="token operator">=</span><span class="token string">"EN"</span> Content<span class="token operator">=</span><span class="token string">"vacation,greece,sunshine"</span>Meta name<span class="token operator">=</span><span class="token string">"Description"</span> Content<span class="token operator">=</span><span class="token string">"你网页的简述"</span>Meta name<span class="token operator">=</span><span class="token string">"Robots"</span> Content<span class="token operator">=</span><span class="token string">"All|None|Index|Noindex|Follow|Nofollow"</span>   <span class="token punctuation">[</span>all：文件将被检索，且页面上的链接可以被查询；   none：文件将不被检索，且页面上的链接不可以被查询；<span class="token punctuation">(</span>和 <span class="token string">"noindex, no follow"</span> 起相同作用<span class="token punctuation">)</span>   index：文件将被检索；（让robot/spider登录）   follow：页面上的链接可以被查询；   noindex：文件将不被检索，但页面上的链接可以被查询；<span class="token punctuation">(</span>不让robot/spider登录<span class="token punctuation">)</span>   nofollow：文件将不被检索，页面上的链接可以被查询。<span class="token punctuation">(</span>不让robot/spider顺着此页的连接往下探找<span class="token punctuation">)</span><span class="token punctuation">]</span>  Meta name<span class="token operator">=</span><span class="token string">"Author"</span> Content<span class="token operator">=</span><span class="token string">"张三，abc@sina.com"</span>Meta name<span class="token operator">=</span><span class="token string">"Copyright"</span> Content<span class="token operator">=</span><span class="token string">"本页版权归Zerospace所有。All Rights Reserved"</span>Meta name<span class="token operator">=</span><span class="token string">"Generator"</span> Content<span class="token operator">=</span><span class="token string">"PCDATA|FrontPage|"</span>META name<span class="token operator">=</span><span class="token string">"revisit-after"</span> CONTENT<span class="token operator">=</span><span class="token string">"7 days"</span></code></pre><p>3.提高网页加载速度</p><ul><li>把js和css写到外部文档、实现结构行为表现的分离。</li><li>去掉不必要的空格和注释等。</li><li>尽量不使用table布局，尽量使用不嵌套的table布局。</li><li>指定图像和table的大小。</li><li>尽量不要使用图像来代替文本(例如在导航栏)。</li><li>延迟js脚本加载，将脚本放在页面底部。</li><li>尽量使用png格式的图像.</li></ul><h3 id="XHTML和HTML的区别"><a href="#XHTML和HTML的区别" class="headerlink" title="XHTML和HTML的区别"></a>XHTML和HTML的区别</h3><p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言。</p><p>最主要的不同：</p><ul><li>XHTML元素必须被正确地嵌套。<br>  标签由外到内，一层层包覆着，所以假设你先写div后写h1，结尾就要先写h1后写div。只要记住一个原则“先进后出”，先弹出的标签要后结尾。</li><li>XHTML元素必须被关闭。<br>  当出现一个标签时，必须要有对应的结束标签，缺一不可，就像在任何程序语言中的括号一样。对于空标签，也必须使用结束标签，或者其开始标签必须使用”/&gt;”结尾。</li><li>元素必须用小写字母。</li><li>XHTML文档必须拥有根元素。<br>  所有的 XHTML 元素必须被嵌套于&lt;html&gt; 根元素中。其余所有的元素均可有子元素。子元素必须是成对的且被嵌套在其父元素之中。</li></ul><h3 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a>严格模式与混杂模式</h3><p>1.Doctype的作用</p><p>&lt;!DOCTYPE&gt;声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。&lt;!DOCTYPE&gt;声明必须在HTML文档的第一行，这并不是一个HTML标签。</p><p>2.严格模式与混杂模式的来源</p><p>当年Netscape4（网景公司早期的浏览器）和IE4（微软公司早期的浏览器）实现CSS机制时，并没有遵循W3C提出的标准。Netscape4 提供了糟糕的支持，而IE4 虽然接近标准，但依旧未能完全正确的支持标准。尽管IE 5 修复了IE4 许多的问题，但是依然延续CSS实现中的其它故障（主要是盒模型问题）。</p><p>为了保障自己的网站在各个浏览器上显示正确，网页开发者们不得不依据各个浏览器自身的规范来使用css，因此大部分网站的css实现并不符合W3C规范的标准。</p><p>然而随着标准一致性越来越重要，浏览器开发商不得不面临一个艰难的抉择：逐渐遵循W3C的标准是前进的方向。但是改变现有的 css，完全去遵循标准，会使许多旧网站或多或少受到破坏，如果浏览器突然以正确的方式解析现存的css，陈旧的网站的显示必然会受到影响。所以，所有的浏览器都需要提供两种模式：混杂模式服务于旧式规则，而严格模式服务于标准规则。</p><p>3.概念</p><p>严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。</p><p>混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。</p><p>4.区分</p><p>浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。</p><ul><li>如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式） </li><li>包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式） </li><li>DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）</li><li>HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）</li></ul><p>严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</p><p>5.两种模式不同点</p><ul><li>盒模型的高宽包含内边距padding和边框border<br>  在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在IE5.5及以下的浏览器及其他版本的Quirks模式下，IE的宽度和高度还包含了padding和border。</li><li>可以设置行内元素的高宽<br>  在严格模式下，给span等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。</li><li>可设置百分比的高度<br>  在严格模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</li><li>用margin:0 auto设置水平居中在IE下会失效<br>  使用margin:0 auto在严格模式下可以使元素水平居中，但在quirks模式下却会失效,quirk模式下的解决办法，用text-align属性:body{text-align:center};#content{text-align:left}</li><li>quirk模式下设置图片的padding会失效</li><li>quirk模式下Table中的字体属性不能继承上层的设置</li><li>quirk模式下white-space:pre会失效</li></ul><p>6.常用的具体声明</p><ul><li>HTML5(一种)：<pre class=" language-bash"><code class="language-bash">  <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span></code></pre></li><li>HTML 4.01(三种)<br>  严格模式包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font），不允许框架集（Framesets）；过渡模式包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font），不允许框架集（Framesets）；框架模式等同于过渡模式，但允许框架集内容。<pre class=" language-bash"><code class="language-bash">  HTML 4.01 Strict ：    <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC <span class="token string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/strict.dtd"</span><span class="token operator">></span>  HTML 4.01 Transitional ：    <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC <span class="token string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>  <span class="token string">"http://www.w3.org/TR/html4/loose.dtd"</span><span class="token operator">></span>  HTML 4.01 Frameset ：    <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE HTML PUBLIC <span class="token string">"-//W3C//DTD HTML 4.01 Frameset//EN"</span>  <span class="token string">"http://www.w3.org/TR/html4/frameset.dtd"</span><span class="token operator">></span></code></pre></li><li>XHTML 1.0(四种)<br>  前三种模式同上，XHML 必须以格式正确的 XML 来编写标记。<pre class=" language-bash"><code class="language-bash">  XHTML 1.0 Strict ：    <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span>  <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span><span class="token operator">></span>  XHTML 1.0 Transitional ：    <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="token string">" http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span><span class="token operator">></span>  XHTML 1.0 Frameset：     <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Frameset//EN"</span>  <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"</span><span class="token operator">></span>  XHTML 1.1 的 DTD 等同于 XHTML 1.0 Strict，但允许添加模型。    <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.1//EN"</span> <span class="token string">"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"</span><span class="token operator">></span></code></pre><h3 id="行内元素与块级元素"><a href="#行内元素与块级元素" class="headerlink" title="行内元素与块级元素"></a>行内元素与块级元素</h3></li></ul><p>1.区别</p><ul><li>默认情况下，多个行内元素会在同一行，水平排列。块级元素每个元素独占一行，多个块级元素垂直方向排列。</li><li>块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上。行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</li></ul><p>2.示例</p><p>行内元素：&lt;span&gt; &lt;select&gt; &lt;a&gt; &lt;img&gt; &lt;label&gt; &lt;textarea&gt;等。</p><p>块级元素：&lt;div&gt; &lt;h1&gt; &lt;li&gt; &lt;p&gt; &lt;table&gt; &lt;fieldset&gt; &lt;caption&gt;等。</p><p>3.相互转换</p><p>行内元素转块级元素：定义该元素的css样式display:block;<br>块级元素转行内元素：定义该元素的css样式display:inline;</p><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400" height="260"><path d="M0,0 L350,0 L350,250 L0,250 L0,0" style="fill:#fff;stroke:black;stroke-width:1;stroke-dasharray:2"/><path d="M30,30 L320,30 L320,210 L30,210 L30,30" style="fill:#0f0;stroke:black;stroke-width:1"/><path d="M60,60 L290,60 L290,180 L60,180 L60,60" style="fill:#fff;stroke:black;stroke-width:1"/><path d="M90,90 L260,90 L260,150 L90,150 L90,90" style="fill:#fff;stroke:black;stroke-width:1;stroke-dasharray:4"/><text x="145" y="20" textlength="60">margin</text><text x="145" y="50" textlength="60">border</text><text x="145" y="80" textlength="60">padding</text><text x="145" y="110" textlength="60">content</text></svg><p>1.说明</p><ul><li>Margin(外边距) - 盒子与其他元素之间的边距。</li><li>Border(边框) - 盒子的边框宽度。</li><li>Padding(内边距) - 盒子内边距，即边框与文字的间距。</li><li>Content(内容) - 盒子的内容，显示文本和图像。</li></ul><p>2.元素的宽度和高度</p><p>当指定一个CSS元素的宽度和高度属性时，只是设置了内容区域的宽度和高度。</p><p>最终元素的总宽度计算公式是这样的：</p><p><strong> 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距 </strong></p><p>元素的总高度最终计算公式是这样的：</p><p><strong> 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 </strong></p><p>3.浏览器的兼容性问题</p><p>一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。</p><p>虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。</p><p>IE8 及更早IE版本不支持 填充的宽度和边框的宽度属性设。</p><p>解决IE8及更早版本不兼容问题可以在HTML页面声明 &lt;!DOCTYPE html&gt;即可。</p><h3 id="CSS引入方式及link和-import区别"><a href="#CSS引入方式及link和-import区别" class="headerlink" title="CSS引入方式及link和@import区别"></a>CSS引入方式及link和@import区别</h3><p>引入css共有四种方式：内联 内嵌 外链 导入。</p><p>1.内联</p><p>内联方式是指直接在标签元素的style属性中添加CSS样式。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"font-size: 20px"</span><span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><p>这通常是个很不好的书写方式，它只能改变当前标签的样式，如果希望多个div 拥有相同的样式，你不得不重复地为每个div添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。</p><p>2.嵌入</p><p>嵌入方式是指在页面head中的style标签下书写CSS代码。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>style<span class="token operator">></span>        .content <span class="token punctuation">{</span>            background: red<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>/style<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span></code></pre><p>嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。</p><p>3.链接</p><p>链接方式是指在页面head中引入外部的CSS文件。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"style.css"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span></code></pre><p>这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。</p><p>4.导入</p><p>导入方式指的是使用 CSS 规则引入外部 CSS 文件。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>style<span class="token operator">></span>    @import url<span class="token punctuation">(</span>style.css<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/style<span class="token operator">></span></code></pre><p>5.link和@import的区别</p><ul><li><p>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p></li><li><p>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p></li><li><p>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p></li><li><p>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p></li></ul><h3 id="CSS选择器及优先级"><a href="#CSS选择器及优先级" class="headerlink" title="CSS选择器及优先级"></a>CSS选择器及优先级</h3><p>1.CSS选择器<br>CSS选择器基本可以分为通配选择器，标签选择器，类选择器，ID选择器，简单属性选择，具体属性选择，根据部分属性值选择，特定属性选择，从结构上来分还有后代选择器，子元素选择器，相邻兄弟选择器以及伪类。</p><ul><li><p>包含选择符（又称后代选择符） E1 E2{}</p></li><li><p>子对象选择符 E1&gt;E2{}</p></li><li><p>ID选择符 #ID{}</p></li><li><p>类选择符 E.className{}</p></li><li><p>选择符分组 E1,E2,E3{}</p></li></ul><p>2.CSS属性继承</p><p>CSS属性继承即父元素定义的CSS属性，子元素也默认使用了该属性。</p><p>可以继承的有 font-size font-family color等</p><p>不可以继承的有 border padding margin background-color width height等</p><p>3.CSS优先级</p><ul><li>相同权值情况下，CSS样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）：</li></ul><p>优先级为：!important &gt; id &gt; class &gt; tag</p><ul><li>权值不同时，浏览器是根据权值来判断使用哪种css样式的，哪种样式权值高就使用哪种样式。</li></ul><p>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。</p><ul><li>!important的优先级比内联样式优先级高。</li></ul><h3 id="前端页面结构"><a href="#前端页面结构" class="headerlink" title="前端页面结构"></a>前端页面结构</h3><p>1.结构层(HTML)</p><p>对网页内容做出了描述。</p><p>2.表现层(CSS)</p><p>对网页内容的样式进行渲染。</p><p>3.行为层(Javascript)</p><p>对网页的各种交互行为进行定义。</p><h3 id="css的基本语句构成"><a href="#css的基本语句构成" class="headerlink" title="css的基本语句构成"></a>css的基本语句构成</h3><pre class=" language-bash"><code class="language-bash">自定义样式名称 <span class="token punctuation">{</span>    属性1:值1<span class="token punctuation">;</span>    属性2:值2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="常见浏览器及内核"><a href="#常见浏览器及内核" class="headerlink" title="常见浏览器及内核"></a>常见浏览器及内核</h3><ul><li>IE浏览器(Ie内核、Trident内核)</li><li>Firefox浏览器(Gecko)</li><li>谷歌浏览器(webkit)</li><li>opear浏览器(Presto)</li><li>Safari浏览器(webkit)</li></ul><h3 id="几种IE6的BUG及解决方法"><a href="#几种IE6的BUG及解决方法" class="headerlink" title="几种IE6的BUG及解决方法"></a>几种IE6的BUG及解决方法</h3><ul><li><p>IE6怪异解析之padding与border算入宽高<br>  原因：未加文档声明造成非盒模型解析<br>  解决方法：加入文档声明&lt;!doctype html&gt;</p></li><li><p>IE6在块元素、左右浮动、设定marin时造成margin双倍(双边距)<br>  解决方法：display:inline</p></li><li><p>内部盒模型超出父级时，父级被撑大<br>  解决方法：父标签使用overflow:hidden</p></li><li><p>line-height默认行高bug<br>  解决方法：line-height设值</p></li><li><p>行标签之间会有一小段空白<br>  解决方法：float或结构并排(可读性差，不建议)</p></li><li><p>标签高度无法小于19px<br>  解决方法：overflow: hidden;</p></li><li><p>左浮元素margin-bottom失效<br>  解决方法：<br>  1.显示设置高度<br>  2.父标签设置_padding-bottom代替子标签的margin-bottom<br>  3.再放个标签让父标签浮动，子标签margin-bottom，即(margin-bottom与float不同时作用于一个标签)</p></li><li><p>img于块元素中，底边多出空白<br>  解决方法：父级设置overflow: hidden; 或 img { display: block; } 或 _margin: -5px;</p></li><li><p>li之间会有间距<br>  解决方法：float: left;</p></li><li><p>块元素中有文字及右浮动的行元素，行元素换行<br>  解决方法：将行元素置于块元素内的文字前</p></li><li><p>position下的left，bottom错位<br>  解决方法：为父级(relative层)设置宽高或添加*zoom:1</p></li><li><p>子级中有设置position，则父级overflow失效<br>  解决方法：为父级设置position:relative</p></li></ul><h3 id="title与alt的区别"><a href="#title与alt的区别" class="headerlink" title="title与alt的区别"></a>title与alt的区别</h3><p>Alt：当图片不显示时，显示alt中的内容。</p><p>Title：为元素提供信息，鼠标悬停在该元素时，等待1s左右，显示title中的内容。</p><h3 id="css中的reset"><a href="#css中的reset" class="headerlink" title="css中的reset"></a>css中的reset</h3><p>1.常用的CSS reset</p><pre class=" language-bash"><code class="language-bash">html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, font, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td <span class="token punctuation">{</span>   margin: 0<span class="token punctuation">;</span>   padding: 0<span class="token punctuation">;</span>   border: 0<span class="token punctuation">;</span>   outline: 0<span class="token punctuation">;</span>   font-weight: inherit<span class="token punctuation">;</span>   font-style: inherit<span class="token punctuation">;</span>   font-size: 100%<span class="token punctuation">;</span>   font-family: inherit<span class="token punctuation">;</span>   vertical-align: baseline<span class="token punctuation">;</span> <span class="token punctuation">}</span> :focus <span class="token punctuation">{</span>  outline: 0<span class="token punctuation">;</span><span class="token punctuation">}</span> a, a:link, a:visited, a:hover, a:active<span class="token punctuation">{</span>  text-decoration:none<span class="token punctuation">}</span> table <span class="token punctuation">{</span>  border-collapse: separate<span class="token punctuation">;</span>  border-spacing: 0<span class="token punctuation">;</span><span class="token punctuation">}</span> th, td <span class="token punctuation">{</span>  text-align: left<span class="token punctuation">;</span>  font-weight: normal<span class="token punctuation">;</span><span class="token punctuation">}</span> img, iframe <span class="token punctuation">{</span>  border: none<span class="token punctuation">;</span>  text-decoration:none<span class="token punctuation">;</span><span class="token punctuation">}</span> ol, ul <span class="token punctuation">{</span>  list-style: none<span class="token punctuation">;</span><span class="token punctuation">}</span> input, textarea, select, button <span class="token punctuation">{</span>  font-size: 100%<span class="token punctuation">;</span>  font-family: inherit<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">select</span> <span class="token punctuation">{</span>  margin: inherit<span class="token punctuation">;</span><span class="token punctuation">}</span> hr <span class="token punctuation">{</span>  margin: 0<span class="token punctuation">;</span>  padding: 0<span class="token punctuation">;</span>  border: 0<span class="token punctuation">;</span>  color: <span class="token comment" spellcheck="true">#000;</span>  background-color: <span class="token comment" spellcheck="true">#000;</span>  height: 1px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.CSS reset作用</p><p>在 HTML标签在浏览器里有默认的样式，不同浏览器的默认样式之间也会有差别。在切换页面的时候，浏览器的默认样式往往会给我们带来麻烦，影响开发效率。所以解决的方法就是一开始就将浏览器的默认样式全部去掉，更准确说就是通过重新定义标签样式。“覆盖”浏览器的CSS默认属性。最简单的做法就是把浏览器提供的默认样式覆盖掉！这就是CSS reset。</p><h3 id="CSS-sprites"><a href="#CSS-sprites" class="headerlink" title="CSS sprites"></a>CSS sprites</h3><p>1.CSS Sprites简介</p><p>客户端每显示一张图片都会向服务器发送请求，而图片越多请求次数越多，造成延迟的可能性也就越大，给服务器造成的压力也很大，所以通过CSS Sprites技术将多张小图片整合为一张图片，减少对服务器的压力。</p><p>2.CSS Sprites原理</p><p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。</p><p>3.优缺点</p><p><strong> 优点 </strong></p><ul><li><p>利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；</p></li><li><p>CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</p></li><li><p>解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。</p></li><li><p>更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便s。</p></li></ul><p><strong> 缺点 </strong></p><ul><li><p>在图片合并的时候，要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；</p></li><li><p>CSS Sprites在开发的时候比较麻烦，要通过photoshop或其他工具测量计算每一个背景单元的精确位置，非常繁琐。</p></li><li><p>CSS Sprites在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的地方最好不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能往下加图片，这样图片的字节就增加了，还要改动css。</p></li></ul><h3 id="对网站优化的解决方案"><a href="#对网站优化的解决方案" class="headerlink" title="对网站优化的解决方案"></a>对网站优化的解决方案</h3><ul><li>尽可能减少http请求次数，将css, js, 图片各自合并</li><li>使用CDN托管，降低通信距离</li><li>添加Expire/Cache-Control头，提供缓存</li><li>启用Gzip压缩文件</li><li>将css放在页面最上面</li><li>将script放在页面最下面</li><li>避免在css中使用表达式</li><li>将css, js都放在外部文件中</li><li>减少DNS查询</li><li>最小化css, js，减小文件体积</li><li>避免重定向</li><li>移除重复脚本</li><li>配置实体标签ETag</li><li>使用AJAX缓存，让网站内容分批加载，局部更新</li></ul><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>1.什么是HTML语义化</p><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p><p>2.为什么要语义化？</p><ul><li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</li><li>用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul><p>3.写HTML代码时应注意什么</p><ul><li>尽可能少的使用无语义的标签div和span；</li><li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li><li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li><li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li><li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>浮动会使当前标签产生向上浮的效果，同时会影响到前后标签、父级标签的位置及 width height 属性。<br>而且同样的代码，在各种浏览器中显示效果也有可能不相同，这样让清除浮动更难了。</p><ul><li>父级div定义height</li><li>结尾处加空div标签clear:both</li><li>父级div定义伪类:after和zoom</li><li>父级div定义overflow:hidden</li><li>父级div定义overflow:auto</li><li>父级div也一起浮动</li><li>父级div定义display:table</li><li>结尾处加br标签clear:both</li></ul><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="Javascript数据类型"><a href="#Javascript数据类型" class="headerlink" title="Javascript数据类型"></a>Javascript数据类型</h3><p>1.Javascript共有6种数据类型</p><p>基本数据类型：Boolean、Number和String。</p><p>复杂数据类型：object。</p><p>特殊数据类型：Undefined、Null。</p><p>2.typeof函数可以返回6种数据类型</p><p>string、number、object、boolean、undefined、function。</p><p>可以点击<a href="https://yk1062008412.github.io/2017/02/27/js容易混淆的几个函数/#typeof和instanceof" target="_blank" rel="noopener">链接</a>查看详情</p><h3 id="显式类型转换与隐式类型转换"><a href="#显式类型转换与隐式类型转换" class="headerlink" title="显式类型转换与隐式类型转换"></a>显式类型转换与隐式类型转换</h3><p>Javascript属于弱类型语言，声明变量不需要指定类型，对变量赋值也不需要类型检查，但是在有的情况下需要特别转换变量的类型。</p><p>1.显式类型转换</p><p>如下函数属于显式类型转换函数：</p><ul><li>toString() 转换为字符串</li><li>parseInt() 转换为数字</li><li>Number()</li><li>Boolean()</li><li>等</li></ul><p>2.隐式类型转换</p><p>如下函数属于显式类型转换函数：</p><ul><li>‘+’加法运算符</li><li>==</li></ul><p>有的人可能看不太懂为什么 “+” 和 “==” 也是隐式类型转换，我举一个例子：</p><pre class=" language-bash"><code class="language-bash">var m <span class="token operator">=</span> 5 + <span class="token boolean">true</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    //6console.log<span class="token punctuation">(</span>1 <span class="token operator">==</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">true</span></code></pre><p>也就是说，”+”运算符将true转换成了number类型的1，所以可以和5相加，得到结果6。而”==”运算符把true转换成了1，然后来比较，即: 1 == 1 ,所以为true。</p><h3 id="split-join-reverse-函数"><a href="#split-join-reverse-函数" class="headerlink" title="split(),join(),reverse()函数"></a>split(),join(),reverse()函数</h3><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> new Array<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"HTML"</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"CSS"</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"JavaScript"</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"HTML"</span>, <span class="token string">"CSS"</span>, <span class="token string">"JavaScript"</span><span class="token punctuation">]</span>console.log<span class="token punctuation">(</span>a.join<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    // HTML,CSS,JavaScriptconsole.log<span class="token punctuation">(</span>a.reverse<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"JavaScript"</span>, <span class="token string">"CSS"</span>, <span class="token string">"HTML"</span><span class="token punctuation">]</span>var b <span class="token operator">=</span> <span class="token string">'hello JavaScript'</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>b.split<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"h"</span>, <span class="token string">"e"</span>, <span class="token string">"l"</span>, <span class="token string">"l"</span>, <span class="token string">"o"</span>, <span class="token string">" "</span>, <span class="token string">"J"</span>, <span class="token string">"a"</span>, <span class="token string">"v"</span>, <span class="token string">"a"</span>, <span class="token string">"S"</span>, <span class="token string">"c"</span>, <span class="token string">"r"</span>, <span class="token string">"i"</span>, <span class="token string">"p"</span>, <span class="token string">"t"</span><span class="token punctuation">]</span>console.log<span class="token punctuation">(</span>b.split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"hello"</span>, <span class="token string">"JavaScript"</span><span class="token punctuation">]</span></code></pre><p>由实例可以看出：</p><ul><li>split函数用来将字符串分割为数组</li><li>join函数可以将数组中的所有元素拼接为一个字符串</li><li>reverse函数用来将原数组中元素的顺序颠倒。</li></ul><h3 id="数组方法pop-push-unshift-shift"><a href="#数组方法pop-push-unshift-shift" class="headerlink" title="数组方法pop,push,unshift,shift"></a>数组方法pop,push,unshift,shift</h3><ul><li>push()方法</li></ul><p>用于向数组末尾添加元素,并返回新数组的长度</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'h'</span>,<span class="token string">'e'</span>,<span class="token string">'l'</span>,<span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>var m <span class="token operator">=</span> a.push<span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 5console.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"h"</span>, <span class="token string">"e"</span>, <span class="token string">"l"</span>, <span class="token string">"l"</span>, <span class="token string">"o"</span><span class="token punctuation">]</span></code></pre><ul><li>pop()方法</li></ul><p>删除数组最后一个元素,并返回删除的元素。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'h'</span>,<span class="token string">'e'</span>,<span class="token string">'l'</span>,<span class="token string">'l'</span>,<span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>var m <span class="token operator">=</span> a.pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    // oconsole.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"h"</span>, <span class="token string">"e"</span>, <span class="token string">"l"</span>, <span class="token string">"l"</span><span class="token punctuation">]</span></code></pre><ul><li>unshift()方法</li></ul><p>用于向数组头部添加元素，并返回新数组的长度。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span>,<span class="token string">'l'</span>,<span class="token string">'l'</span>,<span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>var m <span class="token operator">=</span> a.unshift<span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 5console.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"h"</span>, <span class="token string">"e"</span>, <span class="token string">"l"</span>, <span class="token string">"l"</span>, <span class="token string">"o"</span><span class="token punctuation">]</span></code></pre><ul><li>shift()方法</li></ul><p>删除数组中的第一个元素，并返回删除的第一个元素的值。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'h'</span>,<span class="token string">'e'</span>,<span class="token string">'l'</span>,<span class="token string">'l'</span>,<span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>var m <span class="token operator">=</span> a.shift<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    // hconsole.log<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token punctuation">[</span><span class="token string">"e"</span>, <span class="token string">"l"</span>, <span class="token string">"l"</span>, <span class="token string">"o"</span><span class="token punctuation">]</span></code></pre><h3 id="事件绑定和普通事件"><a href="#事件绑定和普通事件" class="headerlink" title="事件绑定和普通事件"></a>事件绑定和普通事件</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>Document<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"btn"</span><span class="token operator">></span>点击按钮<span class="token operator">&lt;</span>/button<span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        var btn <span class="token operator">=</span> document.getElementById<span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn.onclick <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console.log<span class="token punctuation">(</span><span class="token string">"普通事件1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        btn.onclick <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console.log<span class="token punctuation">(</span><span class="token string">"普通事件2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        btn.addEventListener<span class="token punctuation">(</span><span class="token string">"click"</span>,function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console.log<span class="token punctuation">(</span><span class="token string">"绑定事件1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>,false<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn.addEventListener<span class="token punctuation">(</span><span class="token string">"click"</span>,function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console.log<span class="token punctuation">(</span><span class="token string">"绑定事件2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>,false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>上述代码输出为：</p><pre class=" language-bash"><code class="language-bash">普通2绑定1绑定2</code></pre><p>由此可以得出结论：</p><p>普通事件中的onclick只支持单个事件，之前的事件会被之后的onclick事件覆盖，而事件绑定中的addEventListener可以添加多个事件，之前的事件不会被覆盖。</p><h3 id="IE和DOM事件流的区别"><a href="#IE和DOM事件流的区别" class="headerlink" title="IE和DOM事件流的区别"></a>IE和DOM事件流的区别</h3><p>1.参数的差别</p><p>attachEvent()的第一个参数比addEventListener()的事件名多一个”on”，且没有第三个参数，因为IE事件模型只支持冒泡事件流;</p><p>2.事件处理函数作用域的区别</p><p>IE中事件处理程序处于全局作用域，其内的this会指向window;</p><p>而用DOM（0或2）级事件的事件处理程序的作用域是元素作用域，其内的this指向其所属的元素.</p><p>例:<br>document.addEventListener(“click”, function(){<br>  if(this == document){<br>    alert(“此时this指向document”);<br>  }<br>}, false);</p><p>3.事件对象event的属性方法的差别</p><table><thead><tr><th style="text-align:left">IE</th><th style="text-align:left">DOM</th></tr></thead><tbody><tr><td style="text-align:left">cancelBubble = true</td><td style="text-align:left">stopPropagation() //停止冒泡</td></tr><tr><td style="text-align:left">returnValue = false</td><td style="text-align:left">preventDefault() //阻止元素默认事件</td></tr><tr><td style="text-align:left">srcEelement</td><td style="text-align:left">target //事件目标</td></tr></tbody></table><h3 id="IE和标准下兼容性的写法举例"><a href="#IE和标准下兼容性的写法举例" class="headerlink" title="IE和标准下兼容性的写法举例"></a>IE和标准下兼容性的写法举例</h3><p>var ev = ev || window.event<br>document.documentElement.clientWidth || document.body.clientWidth<br>var target = ev.srcElement||ev.target</p><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><ul><li><p>GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，参数之间以&amp;相连。POST把提交的数据则放置在是HTTP包的Request body包体中。</p></li><li><p>GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB。</p></li><li><p>在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。</p></li><li><p>POST的安全性要比GET的安全性高。</p></li><li><p>Get是向服务器发送取数据的一种请求，而Post是向服务器提交数据的一种请求。</p></li></ul><h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><p>call和apply方法都是用来调用一个对象的一个方法，以另一个对象来替换当前对象。</p><p>唯一区别就是call方法的第二个参数及之后的参数可以是任意类型，而apply的第二个参数必须是数组形式。</p><p>具体联系和区别，点击<a href="https://yk1062008412.github.io/2017/02/27/js容易混淆的几个函数/#call和apply" target="_blank" rel="noopener">链接</a>查看</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h3 id="阻止事件冒泡和默认事件"><a href="#阻止事件冒泡和默认事件" class="headerlink" title="阻止事件冒泡和默认事件"></a>阻止事件冒泡和默认事件</h3><p>1.阻止事件冒泡,使成为捕获型事件触发机制</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> stopBubble<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     //如果提供了事件对象，则这是一个非IE浏览器    <span class="token keyword">if</span> <span class="token punctuation">(</span> e <span class="token operator">&amp;&amp;</span> e.stopPropagation<span class="token punctuation">)</span>        //因此它支持W3C的stopPropagation<span class="token punctuation">(</span><span class="token punctuation">)</span>方法        e.stopPropagation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        //否则，我们需要使用IE的方式来取消事件冒泡        window.event.cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.停止默认事件默认行为</p><pre class=" language-bash"><code class="language-bash">//阻止浏览器的默认行为 <span class="token keyword">function</span> stopDefault<span class="token punctuation">(</span> e <span class="token punctuation">)</span> <span class="token punctuation">{</span>     //阻止默认浏览器动作<span class="token punctuation">(</span>W3C<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> e <span class="token operator">&amp;&amp;</span> e.preventDefault<span class="token punctuation">)</span>        e.preventDefault<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //IE中阻止函数器默认动作的方式    <span class="token keyword">else</span>        window.event.returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>举例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>Document<span class="token operator">&lt;</span>/title<span class="token operator">></span>    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token variable"><span class="token variable">$(</span>document<span class="token variable">)</span></span>.ready<span class="token punctuation">(</span>function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">$(</span><span class="token string">'div.c1'</span><span class="token punctuation">)</span>.click<span class="token punctuation">(</span>function<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>alert<span class="token punctuation">(</span><span class="token string">'单击了div C1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">$(</span><span class="token string">'div.c2'</span><span class="token punctuation">)</span>.click<span class="token punctuation">(</span>function<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>alert<span class="token punctuation">(</span><span class="token string">'单击了div C2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stopBubble<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable"><span class="token variable">$(</span>document<span class="token variable">)</span></span>.click<span class="token punctuation">(</span>function<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>alert<span class="token punctuation">(</span><span class="token string">'单击了document'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">$(</span><span class="token string">'#txt1'</span><span class="token punctuation">)</span>.val<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">$(</span><span class="token string">'#txt1'</span><span class="token punctuation">)</span>.click<span class="token punctuation">(</span>function<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>stopBubble<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">$(</span><span class="token string">'#txt1'</span><span class="token punctuation">)</span>.keydown<span class="token punctuation">(</span>function<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>stopDefault<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span><span class="token string">'按下了键值'</span>+e.keyCode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">function</span> stopBubble<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            //如果提供了事件对象，则这是一个非IE浏览器            <span class="token keyword">if</span> <span class="token punctuation">(</span> e <span class="token operator">&amp;&amp;</span> e.stopPropagation <span class="token punctuation">)</span>                //因此它支持W3C的stopPropagation<span class="token punctuation">(</span><span class="token punctuation">)</span>方法                e.stopPropagation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                //否则，我们需要使用IE的方式来取消事件冒泡                window.event.cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        //阻止浏览器的默认行为        <span class="token keyword">function</span> stopDefault<span class="token punctuation">(</span> e <span class="token punctuation">)</span> <span class="token punctuation">{</span>            //阻止默认浏览器动作<span class="token punctuation">(</span>W3C<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> e <span class="token operator">&amp;&amp;</span> e.preventDefault <span class="token punctuation">)</span>                e.preventDefault<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                //IE中阻止函数器默认动作的方式            <span class="token keyword">else</span>                window.event.returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"c1"</span><span class="token operator">></span>测试的文字,这里是样式C1,单击以冒泡的形式触发事件.<span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>hr/<span class="token operator">></span>    <span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"c2"</span><span class="token operator">></span>测试的文字,这里是样式C2,单击以捕获的形式触发事件.<span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>hr/<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"txt1"</span> name<span class="token operator">=</span><span class="token string">"Text1"</span> type<span class="token operator">=</span><span class="token string">"text"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>hr/<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><h3 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h3><p>利用&lt;script&gt;标签没有跨域限制的“漏洞”,来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，例如：&lt;script src = &quot;http：//<a href="http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt;,并提供一个回调函数来接收数据(函数名可约定，或通过地址参数传递)。第三方产生的响应为json数据的包装" target="_blank" rel="noopener">www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt;,并提供一个回调函数来接收数据(函数名可约定，或通过地址参数传递)。第三方产生的响应为json数据的包装</a>(故称之为jsonp,即json padding)，形如：callback({“name”:”hax”,”gender”:”Male”}).这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。</p><h3 id="js本地对象，内置对象和宿主对象"><a href="#js本地对象，内置对象和宿主对象" class="headerlink" title="js本地对象，内置对象和宿主对象"></a>js本地对象，内置对象和宿主对象</h3><p>宿主环境：一般宿主环境由外壳程序创建与维护，只要能提供js引擎执行的环境都可称之为外壳程序。如：web浏览器，一些桌面应用系统等。即由web浏览器或是这些桌面应用系统早就的环境即宿主环境。</p><p>1.本地对象：独立于宿主环境的 ECMAScript 实现提供的对象。</p><p>“本地对象”包括：</p><p>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</p><p>本地对象是ECMA-2定义的类（引用类型）。</p><p>2.内置对象：由ECMAScript实现提供的，独立与宿主环境的所有对象，在ECMAScript程序开始执行时出现。</p><p>Global 和 Math。</p><p>内置对象其实也是本地对象。</p><p>3.宿主对象</p><p>由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM都是宿主对象。</p><h3 id="onload和document-ready"><a href="#onload和document-ready" class="headerlink" title="onload和document.ready"></a>onload和document.ready</h3><p>window.onload方法必须等到页面内包括图片的所有元素加载完毕后才能执行。</p><p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</p><p>也就是说，先执行ready方法，再执行onload方法。</p><h3 id="“-”和”-”"><a href="#“-”和”-”" class="headerlink" title="“==”和”===”"></a>“==”和”===”</h3><p>“===”叫做严格运算符，”==”叫做相等运算符。</p><p>严格运算符的运算规则如下:</p><ul><li>不同类型值如果两个值的类型不同，直接返回false。</li><li>同一类的原始类型值同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。</li><li>同一类的复合类型值两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。</li><li>undefined和nullundefined 和 null 与自身严格相等。</li></ul><pre class=" language-bash"><code class="language-bash">console.log<span class="token punctuation">(</span>null <span class="token operator">==</span><span class="token operator">=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    //trueconsole.log<span class="token punctuation">(</span>undefined <span class="token operator">==</span><span class="token operator">=</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>    //true</code></pre><p>相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。</p><p>在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。</p><p>类型转换规则如下：</p><ul><li>原始类型的值原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值，所以题主的问题中会有第二个string输出。</li><li>对象与原始类型值比较对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</li><li>undefined和nullundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。</li><li>相等运算符的缺点相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</li></ul><pre class=" language-bash"><code class="language-bash">console.log<span class="token punctuation">(</span><span class="token string">''</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">false</span>console.log<span class="token punctuation">(</span>0 <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">true</span>console.log<span class="token punctuation">(</span>0 <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">true</span>console.log<span class="token punctuation">(</span>false <span class="token operator">==</span> <span class="token string">'false'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">false</span>console.log<span class="token punctuation">(</span>false <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">true</span>console.log<span class="token punctuation">(</span>false <span class="token operator">==</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">false</span>console.log<span class="token punctuation">(</span>false <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">false</span>console.log<span class="token punctuation">(</span>null <span class="token operator">==</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">true</span>console.log<span class="token punctuation">(</span><span class="token string">' \t\r\n '</span> <span class="token operator">==</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>    // <span class="token boolean">true</span></code></pre><p>这就是为什么建议尽量不要使用相等运算符。至于使用相等运算符会不会对后续代码造成意外影响，答案是有可能会。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> undefined<span class="token punctuation">;</span>if<span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //1<span class="token punctuation">}</span>var b <span class="token operator">=</span> undefined<span class="token punctuation">;</span>if<span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //2<span class="token punctuation">}</span>var c <span class="token operator">=</span> undefined<span class="token punctuation">;</span>if<span class="token punctuation">(</span>c <span class="token operator">==</span><span class="token operator">=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //无输出<span class="token punctuation">}</span></code></pre><p>也就是说当a为undefined时，输出的值会有变化，而在编程中对象变成undefined实在是太常见了。</p><h3 id="Javascript同源策略"><a href="#Javascript同源策略" class="headerlink" title="Javascript同源策略"></a>Javascript同源策略</h3><ul><li><p>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准，其目的是防止某个文档或脚本从多个不同源装载。</p></li><li><p>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合</p></li><li><p>不遵循同源策略的标签：&lt;script&gt;,&lt;img&gt;,&lt;iframe&gt;中的src，href都可以任意链接网络资源。</p></li></ul><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>javascript闭包</title>
      <link href="/2017/08/05/javascript-bi-bao/"/>
      <url>/2017/08/05/javascript-bi-bao/</url>
      
        <content type="html"><![CDATA[<p>本文讲述Javascript的闭包。</p><h2 id="引言-简单了解js闭包"><a href="#引言-简单了解js闭包" class="headerlink" title="引言(简单了解js闭包)"></a>引言(简单了解js闭包)</h2><p>在讲述js闭包之前，我们先来说一个简单的例子:</p><pre><code>var a = 1;function fn(){    var b = 2;    console.log(&quot;a: &quot; + a + &quot;, b: &quot; + b);}fn();    //a: 1, b: 2console.log(&quot;a: &quot; + a + &quot;, b: &quot; + b);    //a: 1, b: undefined</code></pre><p>这个相信大家都可以理解，就是变量的作用域，a为定义的全局变量，b为函数fn内部定义的变量,在函数内部，可以获取到全局变量a的值和函数局部变量b的值。在函数外部，不能获取到局部变量b的值。但是，如果我确实想得到函数fn内部的b元素的值呢？<br><a id="more"></a><br>想一想，这个fn其实是一个方法，既然是个方法，那应该可以给这个方法设置一个返回值吧，那如果将这个函数的返回值设置为b元素，会发生什么情况呢？</p><pre><code>function fn(){    var b = 5;    function fn2(){        console.log(n);    }    return fn2;}var result = fn();result();    //5</code></pre><p>实践证明，这样是可以获取到b元素值的。没错，这就是最简单的js闭包。</p><h2 id="正题-js闭包讲解"><a href="#正题-js闭包讲解" class="headerlink" title="正题(js闭包讲解)"></a>正题(js闭包讲解)</h2><h3 id="js闭包概念："><a href="#js闭包概念：" class="headerlink" title="js闭包概念："></a>js闭包概念：</h3><p>官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>是不是有点看不懂？</p><p>其实，js闭包就是在外部可以访问函数内部的局部变量、参数或声明的其他内部函数。</p><p>可能你会说，那这个算不算闭包呢：</p><pre><code>function f1(){    var a = 1;    f2(a);}function f2(m){    console.log(m);}f1();    //1</code></pre><p>那么，你觉得下边这个函数和上边的有什么区别呢:</p><pre><code>function f1(){    var a = 1;    console.log(a);    }f1();    //1</code></pre><p>这个函数和上边的函数其实并没有什么区别，完全可以合并为同一个函数。只不过有时候为了实现代码模块化或组件化，于是将通用的方法封装了起来，以便于方法的重用，所以它并不是闭包。</p><p>既然我们已经看到了比较简单的js闭包，那么我们再来加一点难度，看一下下面这段代码：</p><pre><code>var name = &#39;张三&#39;;var Comp = {    name : &#39;小张&#39;,    getName : function(){        return this.name;    }}console.log(Comp.getName());    //小张</code></pre><p>这个应该比较容易理解，Comp是一个对象，包含一个name属性和一个名为getName的方法，因为getName方法是属于Comp对象的，所以这个this指向Comp对象。因此调用Comp对象中的getName方法，这时候this.name的值应该是”小张”。</p><p>再加深一点难度：</p><pre><code>var name = &#39;张三&#39;;var Comp = {    name : &#39;小张&#39;,    getName : function(){        var here = this;        return function(){            return here.name;        }    }}console.log(Comp.getName()());    //小张</code></pre><p>在这段代码中，定义了here作为getName()方法的局部变量，所以here指的对象并不是window对象，而是Comp对象。但是，由于返回值中有here，所以这个局部变量就一直存在内存中，当调用Comp.getName()()这个方法时，将here从内存中取出来，由于here指的就是Comp对象，所以返回的值就是Comp.name的值。</p><h2 id="提升-this指向问题"><a href="#提升-this指向问题" class="headerlink" title="提升(this指向问题)"></a>提升(this指向问题)</h2><pre><code>var name = &#39;张三&#39;;var Comp = {    name : &#39;小张&#39;,    getName : function(){        return function(){            return this.name;        }    }}console.log(Comp.getName()());    //张三</code></pre><p>为什么这个函数中的this.name返回的是”张三”呢？我们可以先试着运行一下这个</p><pre><code>console.log(Comp.getName());    //function (){    return this.name;    }</code></pre><p>这段代码输出的是一段字符串，而这段字符串是一个匿名函数，而且此时并没有执行这个方法，仅仅是返回了构成这个方法的字符串而已。然后调用这段字符串构成的方法，也就相当于调用window下的一个匿名函数。那这样说的话，是不是我可以将上边这个函数改成这个样子呢？</p><pre><code>var name = &#39;张三&#39;;var Comp = {    name : &#39;小张&#39;,    getName : function(){        return noNameFun;    }}var noNameFun = function(){    return this.name;}console.log(Comp.getName()());    //张三</code></pre><p>可以看出，这个函数确实输出的是”张三”,也就是说和上边这个函数是一样的。那我们就明白了，noNameFun()是属于window对象的，那么这个方法的this也属于window对象，所以this.name就代表的是”张三”。</p><h2 id="闭包的优点"><a href="#闭包的优点" class="headerlink" title="闭包的优点"></a>闭包的优点</h2><p>闭包的优点有两个：</p><ol><li>可以读取函数内部的变量;</li><li>让这些变量的值始终保持在内存中。</li></ol><h2 id="补充-js闭包内存问题"><a href="#补充-js闭包内存问题" class="headerlink" title="补充(js闭包内存问题)"></a>补充(js闭包内存问题)</h2><p>在我们的使用中，很多时候都会用到js闭包的概念，尤其是模块化开发。然而，js闭包虽然好用的，但是任何事物都有它的两面性，变量保持在内存中是优点，但也存在这样一个问题：</p><p>由于闭包会是函数中的变量一直存在于内存中，导致内存被占用，而如果这样的变量多了的话，会使内存消耗很大。所以，不能滥用闭包，否则会是网页性能变得很差，而且在IE中，有可能导致内存泄露。</p><p>什么是内存被占用，我举个例子来说一下：</p><pre><code>function fn(){    var n = 1;    function add(){        n += 1;        console.log(n);    }    return add;}var result = fn();result();    //2result();    //3result();    //4result();    //5result();    //6</code></pre><p>也就是说，这个变量n是一直存在于内存中的，所以每次调用，n就会加1。</p><h2 id="题外-全局变量和局部变量"><a href="#题外-全局变量和局部变量" class="headerlink" title="题外(全局变量和局部变量)"></a>题外(全局变量和局部变量)</h2><p>对于全局变量和局部变量，有些新手可能不太明白。</p><p>外部声明的变量属于全局变量，方法内部声明的变量属于局部变量。但是如果在方法内部没有用var来声明一个变量，那这个变量应该也是一个全局变量。</p><pre><code>var n = 1;function fn(){    var m = 5;    t = 10;    console.log(m);}console.log(n);    //5console.log(m);    //undefinedconsole.log(t);    //undefinedfn();            //5console.log(m);    //undefinedconsole.log(t);    //10</code></pre><p>为什么在执行fn()函数之前打印”t”这个全局变量会输出”undefined”呢？这个”t”到底是不是全局变量？</p><p>我们可以想一下，我现在声明了一个函数，但是我只是定义了这个函数，并没有调用它。那么这个函数内部的方法是不会执行的，也就是说，在我调用方法fn()之前，这个”t”是并没有被声明的，既然没有被声明，那就肯定会输出”undefined”。但是在调用了fn()函数之后，也就执行了函数内部的方法，即：声明了”t”变量。之后，就肯定可以获取到”t”这个全局变量啦。</p><p>对于函数里的方法也是一样的。</p><pre><code>function fn(){    var n = 1;    nAdd = function(){        n += 1;    }    function f(){        console.log(n);    }    return f;}//nAdd();    //undefinedvar result = fn();result();    //1nAdd();result();    //2nAdd();result();    //3</code></pre><p>本章节完！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kettle_errot_karafLifecycleListenter</title>
      <link href="/2017/07/12/kettle-errot-karaflifecyclelistenter/"/>
      <url>/2017/07/12/kettle-errot-karaflifecyclelistenter/</url>
      
        <content type="html"><![CDATA[<p>使用kettle 6.1 通过命令行批量执行作业的过程中，发现偶尔有作业执行时间会变慢几分钟，查看日志发现改作业开始就报了一个错</p><p><img src="/imgs/kettle_error.png" alt="&quot;kettle_error&quot;"></p><a id="more"></a><p>报错之后才会继续下面的作业，虽然不影响最终作业执行结果，但也延误了一些跑批时间。<br>去pentaho论坛查了一下资料，有人给出两种解决方法：<br>1、(6.0版本)修改 /classes目录下kettle-lifecycle-listeners.xml和kettle-registry-extensions.xml两个文件成下面这样:</p><pre><code>kettle-lifecycle-listeners.xml&lt;listeners&gt;&lt;/listeners&gt;kettle-registry-extensions.xml&lt;registry-extensions&gt;&lt;/registry-extensions&gt;</code></pre><p>2、(6.1版本)修改/system/karaf/etc/org.apache.karaf.features.cfg</p><pre><code>把featuresBoot=config,pentaho-client,pentaho-metaverse,pdi-dataservice,pdi-data-refinery改成featuresBoot=config,pentaho-client,pentaho-metaverse,pdi-dataservice</code></pre><p>然后删除 /system/karaf/caches目录</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kettle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>30分钟学习shell脚本</title>
      <link href="/2017/06/07/learn-shell/"/>
      <url>/2017/06/07/learn-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell需要依赖其他程序才能完成大部分的工作，这或许是它的缺陷，但它不容置疑的长处是：简洁的脚本语言标记方式，而且比C语言编写的程序执行更快、更有效率。<br><a id="more"></a></p><h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。<br>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li></ul><p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。<br>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。</p><p>#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。<br>输入一些代码，第一行一般是这样：<br>实例</p><pre><code>#!/bin/bashecho &quot;Hello World !&quot;</code></pre><p>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br>echo 命令用于向窗口输出文本。</p><h2 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a>运行 Shell 脚本有两种方法：</h2><p>1、作为可执行程序<br>将上面的代码保存为 test.sh，并 cd 到相应目录：</p><blockquote><p>chmod +x ./test.sh  #使脚本具有执行权限<br>./test.sh  #执行脚本</p></blockquote><p>注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。<br>2、作为解释器参数<br>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><blockquote><p>/bin/sh test.sh<br>/bin/php test.php</p></blockquote><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h1 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h1><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p><blockquote><p>your_name=”runoob.com”</p></blockquote><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：<br>首个字符必须为字母（a-z，A-Z）。<br>中间不能有空格，可以使用下划线（_）。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。<br>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><blockquote><p>for file in <code>ls /etc</code></p></blockquote><p>以上语句将 /etc 下目录的文件名循环出来。</p><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。<br>推荐给所有变量加上花括号，这是个好的编程习惯。<br>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符（$）。</p><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。<br>下面的例子尝试更改只读变量，结果报错：</p><pre><code>#!/bin/bashmyUrl=&quot;http://www.w3cschool.cc&quot;readonly myUrlmyUrl=&quot;http://www.runoob.com&quot;</code></pre><p>运行脚本，结果如下：<br>/bin/sh: NAME: This variable is read only.</p><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 unset 命令可以删除变量。语法：</p><blockquote><p>unset variable_name </p></blockquote><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>运行shell时，会同时存在三种变量：<br>1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。<br>2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。<br>3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行.</p><h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。<br>类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。<br>定义数组<br>在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<br>数组名=(值1 值2 … 值n)<br>例如：<br>array_name=(value0 value1 value2 value3)</p><p>获取数组的长度<br>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><pre><code># 取得数组元素的个数length=${#array_name[@]}# 或者length=${#array_name[*]}# 取得数组单个元素的长度lengthn=${#array_name[n]</code></pre><h2 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h2><p>以”#”开头的行就是注释，会被解释器忽略。<br>sh里没有多行注释，只能每一行加一个#号。只能像这样：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原生js操作DOM元素</title>
      <link href="/2017/06/05/yuan-sheng-js-cao-zuo-dom-yuan-su/"/>
      <url>/2017/06/05/yuan-sheng-js-cao-zuo-dom-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述一些原生的js来操作DOM元素的方法。</p><p>目前市场上的一些js库很多：jQuery、Angular、prototype、lodash、react、vue等方便了我们应用。但有时候如果开发一些自己的js库，还是要用到原生js。<br><a id="more"></a></p><h2 id="当前元素节点"><a href="#当前元素节点" class="headerlink" title="当前元素节点"></a>当前元素节点</h2><ul><li>obj.getElementById()<br>  返回带有指定 ID 的元素。</li><li>obj.getElementsByTagName()<br>  返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。</li><li>obj.etElementsByClassName()<br>  返回包含带有指定类名的所有元素的节点列表。</li><li>obj.getElementsByName()<br>  方法可返回带有指定名称的对象的集合。</li></ul><h2 id="元素相关节点"><a href="#元素相关节点" class="headerlink" title="元素相关节点"></a>元素相关节点</h2><ul><li>node.childNodes<br>  只读 childNodes 属性返回节点的子节点集合，以 NodeList 对象。注意他包括文本节点和元素节点(即像换行，空白这些也算 .nodeName 当前元素类型名称|.nodeType 当前元素类型)</li><li>node.children<br>  只读 children则不包括文本节点，只有元素节点，子节点列表。</li><li>node.firstChild<br>  只读 node里的第一个节点 （注意，标准下包含文本节点+元素节点  非标准下只含元素节点）推荐使用children[0]</li><li>node.lastChild<br>  只读 node里的最后一个节点</li><li>node.nextSibling || node.nextElementSibling<br>  下一个兄弟节点 （注意，这个包含文本节点，前者标准和非标，后者ie下没有）</li><li>node.previousSibling || node.previousElementSibling<br>  上一个兄弟节点 （注意，这个包含文本节点，前者标准和非标，后者ie下没有）</li><li>node.parentNode<br>  node的父亲节点，仅有一个 只读 无兼容问题。</li><li>node.offsetParent<br>  只读 父节点（有定位的父节点，有多个则离他最近的一个）<br>  1.如果没有定位的父节点则博人body。<br>  2.如果他自身是定位则ie7以下为html，其他为body。<br>  3.如果他的父级有一个设置了zoom：1 则表示这个父级</li></ul><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><ul><li>document/node.createElement(“标签名”)<br>  创建元素节点。</li><li>createTextNode(内容)<br>  创建文本节点。</li><li>node.appendChild(node)<br>  把新的子节点添加到该node节点里面并且是最后面。这个新节点可以是文档中某个已存在的节点，也可以是创建新的节点。</li><li>node.insertBefore(newnode必填,existingnode)<br>  在该节点里面指定的子节点前面插入新的子节点。这个新节点可以是文档中某个已存在的节点，也可以是创建新的节点。</li><li>node.removeChild(node)<br>  删除该节点里面的node子节点。</li><li>node.replaceChild(newnode,oldnode)<br>  新替换该节点里面旧(newnode,oldnode)这个新节点可以是文档中某个已存在的节点，也可以是创建新的节点。</li><li>createAttribute()<br>  创建属性节点。</li><li>element.getAttribute(属性名)<br>  返回指定的属性值。</li><li>element.setAttribute(属性名，属性值)<br>  setAttribute() 方法添加指定的属性，并为其赋指定的值。如果这个指定的属性已存在，则仅设置/更改值</li></ul><h2 id="浏览器宽高"><a href="#浏览器宽高" class="headerlink" title="浏览器宽高"></a>浏览器宽高</h2><ul><li>div容器宽: obj.style.width;</li><li>div容器高: obj.style.height;</li><li>网页可见区域宽: document.body.clientWidth;</li><li>网页可见区域高: document.body.clientHeight;</li><li>网页可见区域宽: document.body.offsetWidth   (包括边线的宽);</li><li>网页可见区域高: document.body.offsetHeight  (包括边线的宽);</li><li>网页正文全文宽: document.body.scrollWidth;</li><li>网页正文全文高: document.body.scrollHeight;</li><li>网页被卷去的高: document.body.scrollTop;</li><li>网页被卷去的左: document.body.scrollLeft;</li><li>网页正文部分上: window.screenTop;</li><li>网页正文部分左: window.screenLeft;</li><li>屏幕分辨率的高: window.screen.height;</li><li>屏幕分辨率的宽: window.screen.width;</li><li>屏幕可用工作区高度：window.screen.availHeight;</li><li>屏幕可用工作区宽度：window.screen.availWidth;</li><li>滚动条滚动距离:scrollLeft/scrollTop<br>  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;</li><li>边框的厚度: clientLeft/clientTop</li><li>鼠标位置: ev.clientX/ev.clientY</li></ul><h2 id="基于jQuery一些方法"><a href="#基于jQuery一些方法" class="headerlink" title="基于jQuery一些方法"></a>基于jQuery一些方法</h2><ul><li>目标选择器距离网页页面顶端的高度<br>  var test = $(“.test”).offset().top;</li><li>浏览器窗口的高度<br>  var win_h = $(window).height();</li><li>滚动条的高度<br>  var scr_h = $(window).scrollTop();</li><li>滚动窗口触发事件函数<pre class=" language-bash"><code class="language-bash">  <span class="token variable"><span class="token variable">$(</span>window<span class="token variable">)</span></span>.scroll<span class="token punctuation">(</span>function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      //<span class="token punctuation">..</span>.  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http协议</title>
      <link href="/2017/05/22/http-xie-yi/"/>
      <url>/2017/05/22/http-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。<br><a id="more"></a></p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。<br><b>HTTP三点注意事项：</b><br>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。<br>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>以下图表展示了HTTP协议通信流程</p><p><img src="/imgs/Http/cgiarch.gif" alt="&quot;通信流程&quot;"></p><h1 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h1><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。<br>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。<br>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。<br>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p><h2 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式</p><p><img src="/imgs/Http/2.png" alt="&quot;格式&quot;"></p><h2 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h2><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。<br><img src="/imgs/Http/3.jpg" alt="&quot;响应结构&quot;"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面实例是一点典型的使用GET来传递数据的实例：<br>客户端请求：</p><pre><code>GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi</code></pre><p>服务端响应:</p><pre><code>HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: &quot;34aa387-d-1568eb00&quot;Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain</code></pre><p>输出结果：</p><pre><code>Hello World! My payload includes a trailing CRLF.</code></pre><h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>2</td><td>HEAD</td><td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>6</td><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td></td></tr></tbody></table><h1 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h1><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。<br>在本章节中我们将具体来介绍HTTP响应头信息</p><table class=""><br>        <tr><br>            <td>应答头 </td><br>            <td>说明 </td><br>        </tr><br>        <tr><br>            <td>Allow </td><br>            <td><p>服务器支持哪些请求方法（如GET、POST等）。</p></td><br>        </tr><br>        <tr><br>            <td>Content-Encoding</td><br>            <td><p>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</p></td><br>        </tr><br>        <tr><br>            <td>Content-Length </td><br>            <td><p>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</p></td><br>        </tr><br>        <tr><br>            <td>Content-Type</td><br>            <td><p>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</p></td><br>        </tr><br>        <tr><br>            <td>Date </td><br>            <td><p>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</p> </td><br>        </tr><br>        <tr><br>            <td>Expires </td><br>            <td><p>应该在什么时候认为文档已经过期，从而不再缓存它？</p></td><br>        </tr><br>        <tr><br>            <td>Last-Modified</td><br>            <td><p>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</p></td><br>        </tr><br>        <tr><br>            <td>Location </td><br>            <td><p>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 </p></td><br>        </tr><br>        <tr><br>            <td>Refresh</td><br>            <td><p>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。" target="_blank" rel="noopener">http://host/path&quot;)让浏览器读取指定的页面。</a> <br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。" target="_blank" rel="noopener">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a> <br><br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 <br><br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p></td><br>        </tr><br>        <tr><br>            <td>Server</td><br>            <td><p>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</p></td><br>        </tr><br>        <tr><br>            <td>Set-Cookie </td><br>            <td><p>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</p></td><br>        </tr><br>        <tr><br>            <td>WWW-Authenticate</td><br>            <td><p>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 <br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</p></td><br>        </tr><br></table>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centos安装pgsql</title>
      <link href="/2017/05/15/centos-an-zhuang-pgs/"/>
      <url>/2017/05/15/centos-an-zhuang-pgs/</url>
      
        <content type="html"><![CDATA[<h1 id="安装PostgreSQL源"><a href="#安装PostgreSQL源" class="headerlink" title="安装PostgreSQL源"></a>安装PostgreSQL源</h1><p>CentOS 6.x 32bit</p><pre><code>sudo rpm -Uvh http://yum.postgresql.org/9.4/redhat/rhel-6-i386/pgdg-centos94-9.4-1.noarch.rpm</code></pre><p>CentOS 6.x 64bit</p><pre><code>sudo rpm -Uvh http://yum.postgresql.org/9.4/redhat/rhel-6-x86_64/pgdg-centos94-9.4-1.noarch.rpm</code></pre><p>CentOS 7 64bit</p><pre><code>sudo rpm -Uvh http://yum.postgresql.org/9.4/redhat/rhel-7-x86_64/pgdg-centos94-9.4-1.noarch.rpm</code></pre><p>在添加源的步骤中并没有太多的区别，主要是源的地址有一定的变化。<br><a id="more"></a></p><h1 id="执行安装命令"><a href="#执行安装命令" class="headerlink" title="执行安装命令"></a>执行安装命令</h1><pre><code>sudo yum updatesudo yum install postgresql94-server postgresql94-contrib</code></pre><h1 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h1><pre><code>sudo rpm -aq| grep postgres</code></pre><p>执行结果如下：</p><pre><code>postgresql94-libs-9.4.1-1PGDG.rhel7.x86_64postgresql94-server-9.4.1-1PGDG.rhel7.x86_64postgresql94-9.4.1-1PGDG.rhel7.x86_64postgresql94-contrib-9.4.1-1PGDG.rhel7.x86_64</code></pre><h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><p>CentOS 6.x 系统</p><pre><code>sudo service postgresql-9.4 initdb</code></pre><p>CentOS 7 系统</p><pre><code>sudo /usr/pgsql-9.4/bin/postgresql94-setup initdb</code></pre><p>在初始化数据库时可以指定参数 –PGDATA=“/data”，该参数是用于指明数据库的数据文件的存放路径，默认是在/var/lib/pgsql/9.4/data路径下。</p><p>如果我在CentOS 7下执行 service postgresql-9.4 initdb 将会报如下问题</p><pre><code>The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</code></pre><h1 id="启动服务并设置为开机启动"><a href="#启动服务并设置为开机启动" class="headerlink" title="启动服务并设置为开机启动"></a>启动服务并设置为开机启动</h1><p>CentOS 6.x 系统</p><pre><code>sudo service postgresql-9.4 startsudo chkconfig postgresql-9.4 on</code></pre><p>CentOS 7 系统</p><pre><code>sudo systemctl enable postgresql-9.4sudo systemctl start postgresql-9.4</code></pre><h1 id="开放防火墙端口"><a href="#开放防火墙端口" class="headerlink" title="开放防火墙端口"></a>开放防火墙端口</h1><p>CentOS 6.x 系统</p><pre><code>vi /etc/sysconfig/iptables</code></pre><p>按下I进入输入模式，在文件中加入一下语句</p><pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 5432 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</code></pre><p>输入完成后按ESC退出编辑模式，输入:wq退出VI编辑界面。</p><p>重启防火墙服务</p><pre><code>sudo service iptables restart</code></pre><p>CentOS 7 系统</p><pre><code>sudo firewall-cmd --permanent --add-port=5432/tcpsudo firewall-cmd --permanent --add-port=80/tcpsudo firewall-cmd --reload</code></pre><h1 id="访问PostgreSQL"><a href="#访问PostgreSQL" class="headerlink" title="访问PostgreSQL"></a>访问PostgreSQL</h1><pre><code>su - postgres</code></pre><p>输出结果如下：</p><pre><code>上一次登录：一 5月 18 15:17:29 CST 2015pts/0 上-bash-4.2$</code></pre><p>输入命令psql将看到PostgrSQL的版本信息。</p><p>psql (9.4.1)<br>输入 “help” 来获取帮助信息.</p><h1 id="设置postgres用户密码"><a href="#设置postgres用户密码" class="headerlink" title="设置postgres用户密码"></a>设置postgres用户密码</h1><pre><code>postgres=# \password postgres</code></pre><h1 id="修改PostgresSQL-数据库配置实现远程访问"><a href="#修改PostgresSQL-数据库配置实现远程访问" class="headerlink" title="修改PostgresSQL 数据库配置实现远程访问"></a>修改PostgresSQL 数据库配置实现远程访问</h1><h2 id="修改postgresql-conf-文件"><a href="#修改postgresql-conf-文件" class="headerlink" title="修改postgresql.conf 文件"></a>修改postgresql.conf 文件</h2><h1 id="vi-var-lib-pgsql-data-postgresql-conf"><a href="#vi-var-lib-pgsql-data-postgresql-conf" class="headerlink" title="vi /var/lib/pgsql/data/postgresql.conf"></a>vi /var/lib/pgsql/data/postgresql.conf</h1><p>如果想让PostgreSQL 监听整个网络的话，将listen_addresses 前的#去掉，并将 listen_addresses = ‘localhost’ 改成 listen_addresses = ‘*’</p><h2 id="修改客户端认证配置文件pg-hba-conf"><a href="#修改客户端认证配置文件pg-hba-conf" class="headerlink" title="修改客户端认证配置文件pg_hba.conf"></a>修改客户端认证配置文件pg_hba.conf</h2><p>将需要远程访问数据库的IP地址或地址段加入该文件。</p><h1 id="vi-var-lib-pgsql-9-2-data-pg-hba-conf"><a href="#vi-var-lib-pgsql-9-2-data-pg-hba-conf" class="headerlink" title="vi /var/lib/pgsql/9.2/data/pg_hba.conf"></a>vi /var/lib/pgsql/9.2/data/pg_hba.conf</h1><h1 id="重启服务以使设置生效"><a href="#重启服务以使设置生效" class="headerlink" title="重启服务以使设置生效"></a>重启服务以使设置生效</h1><h1 id="service-postgresql-9-2-restart"><a href="#service-postgresql-9-2-restart" class="headerlink" title="service postgresql-9.2 restart"></a>service postgresql-9.2 restart</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pgsql </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux的iptables开发mysql端口</title>
      <link href="/2017/05/15/linux-de-iptables-kai-fa-mysql-duan-kou/"/>
      <url>/2017/05/15/linux-de-iptables-kai-fa-mysql-duan-kou/</url>
      
        <content type="html"><![CDATA[<p>修改防火墙配置文件：</p><pre><code>vi /etc/sysconfig/iptables</code></pre><p>增加下面一行：</p><pre><code>-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</code></pre><p>如果想开通21等端口，只需要将3306换成21等要开放的端口就可以了。<br>配置后，重新启动iptable</p><pre><code>service iptables restart</code></pre><p>这时就可以从外网访问MySQL了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谷歌HTML/CSS规范</title>
      <link href="/2017/04/24/gu-ge-html-css-gui-fan/"/>
      <url>/2017/04/24/gu-ge-html-css-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://google.github.io/styleguide/htmlcssguide.html" target="_blank" rel="noopener">https://google.github.io/styleguide/htmlcssguide.html</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这篇文章定义了 HTML 和 CSS 的格式和代码规范，旨在提高代码质量和协作效率。<br><a id="more"></a></p><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="通用样式规范"><a href="#通用样式规范" class="headerlink" title="通用样式规范"></a>通用样式规范</h3><h4 id="URL协议"><a href="#URL协议" class="headerlink" title="URL协议"></a>URL协议</h4><p>省略img图片、css样式、Javascript脚本以及其他媒体文件 URL 的协议部分(http:,https:),除非文件在两种协议下都不可用。这种方案称为 protocol-relative URL，好处是无论你是使用HTTPS 还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，同时可以节省一部分字节。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://www.google.com/js/gweb/analytics/autotrack.js"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"//www.google.com/js/gweb/analytics/autotrack.js"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span>.example <span class="token punctuation">{</span>  background: url<span class="token punctuation">(</span>https://www.google.com/images/example<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span>.example <span class="token punctuation">{</span>  background: url<span class="token punctuation">(</span>//www.google.com/images/example<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="通用格式规范"><a href="#通用格式规范" class="headerlink" title="通用格式规范"></a>通用格式规范</h3><h4 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h4><p>一次缩进2个空格</p><p>不要使用制表符(tab键)或混合tab键和空格进行缩进。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>ul<span class="token operator">></span>  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>/li<span class="token operator">></span>  <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>/li<span class="token operator">></span><span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><pre class=" language-bash"><code class="language-bash">.example<span class="token punctuation">{</span>  color:blue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><p>以下元素都应尽量使用小写：<br>HTML元素名称、属性、属性值(除非text/CDATA)，CSS选择器，属性和属性值(字符串除外)。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>A HREF<span class="token operator">=</span><span class="token string">"/"</span><span class="token operator">></span>Home<span class="token operator">&lt;</span>/A<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"google.png"</span> alt<span class="token operator">=</span><span class="token string">"Google"</span><span class="token operator">></span></code></pre><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */color: <span class="token comment" spellcheck="true">#E5E5E5;</span>/* 推荐使用 */color: <span class="token comment" spellcheck="true">#e5e5e5;</span></code></pre><h4 id="结尾空格"><a href="#结尾空格" class="headerlink" title="结尾空格"></a>结尾空格</h4><p>结尾的空格是比较多余的，可能使代码更加复杂化。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>What?_<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>Yes please.<span class="token operator">&lt;</span>/p<span class="token operator">></span></code></pre><h3 id="通用元规范"><a href="#通用元规范" class="headerlink" title="通用元规范"></a>通用元规范</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>在 HTML 中需要指定编码方式，CSS 中不需要指定，因为默认是 UTF-8。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>使用注释来解释代码：包含的模块，功能以及优点。便于后期维护。</p><h4 id="任务项"><a href="#任务项" class="headerlink" title="任务项"></a>任务项</h4><p>用 TODO 来标记待办事项，而不是用一些其他的标记，像 @@。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- TODO: remove optional tags --<span class="token operator">></span><span class="token operator">&lt;</span>ul<span class="token operator">></span>  <span class="token operator">&lt;</span>li<span class="token operator">></span>Apples<span class="token operator">&lt;</span>/li<span class="token operator">></span>  <span class="token operator">&lt;</span>li<span class="token operator">></span>Oranges<span class="token operator">&lt;</span>/li<span class="token operator">></span><span class="token operator">&lt;</span>/ul<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- @ remove optional tags @ --<span class="token operator">></span><span class="token operator">&lt;</span>ul<span class="token operator">></span>  <span class="token operator">&lt;</span>li<span class="token operator">></span>Apples<span class="token operator">&lt;</span>/li<span class="token operator">></span>  <span class="token operator">&lt;</span>li<span class="token operator">></span>Oranges<span class="token operator">&lt;</span>/li<span class="token operator">></span><span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML-风格规范"><a href="#HTML-风格规范" class="headerlink" title="HTML 风格规范"></a>HTML 风格规范</h3><h4 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h4><p>HTML 文档应使用 HTML5 的文档类型：&lt;!DOCTYPE html&gt;。<br>单标记标签无需封闭自身，<br> 不要写成 <br>。</p><h4 id="HTML-正确性"><a href="#HTML-正确性" class="headerlink" title="HTML 正确性"></a>HTML 正确性</h4><p>尽可能使用正确的 HTML。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>Test<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>article<span class="token operator">></span>This is only a test.<span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>Test<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>article<span class="token operator">></span>This is only a test.<span class="token operator">&lt;</span>/article<span class="token operator">></span></code></pre><h4 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h4><p>根据使用场景选择正确的 HTML 元素（有时被错误的称为“标签”）。例如，使用  h1 元素创建标题，p 元素创建段落，a 元素创建链接等等。正确的使用 HTML 元素对于可访问性、可重用性、搜索引擎以及编码效率都很重要。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>div onclick<span class="token operator">=</span><span class="token string">"goToRecommendations();"</span><span class="token operator">></span>All recommendations<span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"recommendations/"</span><span class="token operator">></span>All recommendations<span class="token operator">&lt;</span>/a<span class="token operator">></span></code></pre><h4 id="多媒体元素降级"><a href="#多媒体元素降级" class="headerlink" title="多媒体元素降级"></a>多媒体元素降级</h4><p>对于像图片、视频、canvas 动画等多媒体元素，确保提供其他可访问的内容。图片可以使用替代文本（alt），视频和音频可以使用文字版本。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"spreadsheet.png"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"spreadsheet.png"</span> alt<span class="token operator">=</span><span class="token string">"Spreadsheet screenshot."</span><span class="token operator">></span></code></pre><h4 id="关注分离"><a href="#关注分离" class="headerlink" title="关注分离"></a>关注分离</h4><p>标记、样式和脚本分离，确保相互耦合最小化。</p><h4 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h4><p>如果团队中文件和编辑器使用同样的编码方式，就没必要使用实体引用，如 <code>&amp; mdash;</code>，<code>&amp; rdquo;</code>，<code>&amp; #x263a;</code>，除了一些在 HTML 中有特殊含义的字符（如 &lt; 和 &amp;）以及不可见的字符（如空格）。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span>The currency symbol <span class="token keyword">for</span> the Euro is <span class="token operator">&amp;</span>ldquo<span class="token punctuation">;</span><span class="token operator">&amp;</span>eur<span class="token punctuation">;</span><span class="token operator">&amp;</span>rdquo<span class="token punctuation">;</span><span class="token keyword">.</span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span>The currency symbol <span class="token keyword">for</span> the Euro is “€”.</code></pre><h4 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h4><p>在引用样式表和脚本时，不要指定 type 属性，除非不是 CSS 或 JavaScript。<br>因为 HTML5 中已经默认指定样式变的 type 是 text/css，脚本的type 是 text/javascript。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"//www.google.com/css/maia.css"</span> type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"//www.google.com/css/maia.css"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"//www.google.com/js/gweb/analytics/autotrack.js"</span> type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"//www.google.com/js/gweb/analytics/autotrack.js"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><h3 id="HTML格式规范"><a href="#HTML格式规范" class="headerlink" title="HTML格式规范"></a>HTML格式规范</h3><h4 id="HTML-引号"><a href="#HTML-引号" class="headerlink" title="HTML 引号"></a>HTML 引号</h4><p>属性值应该使用双引号。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 不推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>a class<span class="token operator">=</span><span class="token string">'maia-button maia-button-secondary'</span><span class="token operator">></span>Sign in<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 推荐使用 --<span class="token operator">></span><span class="token operator">&lt;</span>a class<span class="token operator">=</span><span class="token string">"maia-button maia-button-secondary"</span><span class="token operator">></span>Sign in<span class="token operator">&lt;</span>/a<span class="token operator">></span></code></pre><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h3><h4 id="ID-和-Class-命名"><a href="#ID-和-Class-命名" class="headerlink" title="ID 和 Class 命名"></a>ID 和 Class 命名</h4><p>使用有含义的 id 和 class 名称。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用: meaningless */<span class="token comment" spellcheck="true">#yee-1901 {}</span>/* 不推荐使用: presentational */.button-green <span class="token punctuation">{</span><span class="token punctuation">}</span>.clear <span class="token punctuation">{</span><span class="token punctuation">}</span>/* 推荐使用: specific */<span class="token comment" spellcheck="true">#gallery {}</span><span class="token comment" spellcheck="true">#login {}</span>.video <span class="token punctuation">{</span><span class="token punctuation">}</span>/* 推荐使用: generic */.aux <span class="token punctuation">{</span><span class="token punctuation">}</span>.alt <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="ID-和-Class-命名风格"><a href="#ID-和-Class-命名风格" class="headerlink" title="ID 和 Class 命名风格"></a>ID 和 Class 命名风格</h4><p>id 和 class 应该尽量简短，同时要容易理解。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */<span class="token comment" spellcheck="true">#navigation {}</span>.atr <span class="token punctuation">{</span><span class="token punctuation">}</span>/* 推荐使用 */<span class="token comment" spellcheck="true">#nav {}</span>.author <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>除非需要，否则不要在 id 或 class 前加元素名。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */ul<span class="token comment" spellcheck="true">#example {}</span>div.error <span class="token punctuation">{</span><span class="token punctuation">}</span>/* 推荐使用 */<span class="token comment" spellcheck="true">#example {}</span>.error <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h4><p>尽量使用 CSS 中可以简写的属性 (如 font)，可以提高编码效率以及代码可读性。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */border-top-style: none<span class="token punctuation">;</span>font-family: palatino, georgia, serif<span class="token punctuation">;</span>font-size: 100%<span class="token punctuation">;</span>line-height: 1.6<span class="token punctuation">;</span>padding-bottom: 2em<span class="token punctuation">;</span>padding-left: 1em<span class="token punctuation">;</span>padding-right: 1em<span class="token punctuation">;</span>padding-top: 0<span class="token punctuation">;</span>/* 推荐使用 */border-top: 0<span class="token punctuation">;</span>font: 100%/1.6 palatino, georgia, serif<span class="token punctuation">;</span>padding: 0 1em 2em<span class="token punctuation">;</span></code></pre><h4 id="0-和单位"><a href="#0-和单位" class="headerlink" title="0 和单位"></a>0 和单位</h4><p>值为 0 时不用添加单位。</p><pre class=" language-bash"><code class="language-bash">margin: 0<span class="token punctuation">;</span>padding: 0<span class="token punctuation">;</span></code></pre><h4 id="开头的-0"><a href="#开头的-0" class="headerlink" title="开头的 0"></a>开头的 0</h4><p>值在 -1 和 1 之间时，不需要加 0。</p><pre class=" language-bash"><code class="language-bash">font-size: .8em<span class="token punctuation">;</span></code></pre><h4 id="16进制表示法"><a href="#16进制表示法" class="headerlink" title="16进制表示法"></a>16进制表示法</h4><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */color: <span class="token comment" spellcheck="true">#eebbcc;</span>/* 推荐使用 */color: <span class="token comment" spellcheck="true">#ebc;</span></code></pre><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p>使用带前缀的命名空间可以防止命名冲突，同时提高代码可维护性。</p><pre class=" language-bash"><code class="language-bash">.adw-help <span class="token punctuation">{</span><span class="token punctuation">}</span> /* AdWords */<span class="token comment" spellcheck="true">#maia-note {} /* Maia */</span></code></pre><h4 id="ID-和-Class-命名分隔符"><a href="#ID-和-Class-命名分隔符" class="headerlink" title="ID 和 Class 命名分隔符"></a>ID 和 Class 命名分隔符</h4><p>选择器中使用连字符可以提高可读性。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用: 因为没有将“demo” 和 “image” 用分隔符分开 */.demoimage <span class="token punctuation">{</span><span class="token punctuation">}</span>/* 不推荐使用: 因为使用了下划线，而不是分隔符 */.error_status <span class="token punctuation">{</span><span class="token punctuation">}</span>/* 推荐使用 */<span class="token comment" spellcheck="true">#video-id {}</span>.ads-sample <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="CSS格式规则"><a href="#CSS格式规则" class="headerlink" title="CSS格式规则"></a>CSS格式规则</h3><h4 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h4><p>按照属性首字母顺序书写 CSS 易于阅读和维护，排序时可以忽略带有浏览器前缀的属性。</p><pre class=" language-bash"><code class="language-bash">background: fuchsia<span class="token punctuation">;</span>border: 1px solid<span class="token punctuation">;</span>-moz-border-radius: 4px<span class="token punctuation">;</span>-webkit-border-radius: 4px<span class="token punctuation">;</span>border-radius: 4px<span class="token punctuation">;</span>color: black<span class="token punctuation">;</span>text-align: center<span class="token punctuation">;</span>text-indent: 2em<span class="token punctuation">;</span></code></pre><h4 id="块级内容缩进"><a href="#块级内容缩进" class="headerlink" title="块级内容缩进"></a>块级内容缩进</h4><p>为了反映层级关系和提高可读性，块级内容都应缩进。</p><pre class=" language-bash"><code class="language-bash">@media screen, projection <span class="token punctuation">{</span>  html <span class="token punctuation">{</span>    background: <span class="token comment" spellcheck="true">#fff;</span>    color: <span class="token comment" spellcheck="true">#444;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="声明结束"><a href="#声明结束" class="headerlink" title="声明结束"></a>声明结束</h4><p>每行 CSS 都应以分号结尾。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */.test <span class="token punctuation">{</span>  display: block<span class="token punctuation">;</span>  height: 100px<span class="token punctuation">}</span>/* 推荐使用 */.test <span class="token punctuation">{</span>  display: block<span class="token punctuation">;</span>  height: 100px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="属性名结尾"><a href="#属性名结尾" class="headerlink" title="属性名结尾"></a>属性名结尾</h4><p>属性名和值之间都应有一个空格。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */h3 <span class="token punctuation">{</span>  font-weight:bold<span class="token punctuation">;</span><span class="token punctuation">}</span>/* 推荐使用 */h3 <span class="token punctuation">{</span>  font-weight: bold<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="声明样式块的分隔"><a href="#声明样式块的分隔" class="headerlink" title="声明样式块的分隔"></a>声明样式块的分隔</h4><p>在选择器和 {} 之间用空格隔开。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用: 因为缺少空格 */<span class="token comment" spellcheck="true">#video{</span>  margin-top: 1em<span class="token punctuation">;</span><span class="token punctuation">}</span>/* 不推荐使用: 因为有不必要的换行符 */<span class="token comment" spellcheck="true">#video</span><span class="token punctuation">{</span>  margin-top: 1em<span class="token punctuation">;</span><span class="token punctuation">}</span>/* 推荐使用 */<span class="token comment" spellcheck="true">#video {</span>  margin-top: 1em<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="选择器分隔"><a href="#选择器分隔" class="headerlink" title="选择器分隔"></a>选择器分隔</h4><p>每个选择器都另起一行。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */a:focus, a:active <span class="token punctuation">{</span>  position: relative<span class="token punctuation">;</span> top: 1px<span class="token punctuation">;</span><span class="token punctuation">}</span>/* 推荐使用 */h1,h2,h3 <span class="token punctuation">{</span>  font-weight: normal<span class="token punctuation">;</span>  line-height: 1.2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="规则分隔"><a href="#规则分隔" class="headerlink" title="规则分隔"></a>规则分隔</h4><p>规则之间都用空行隔开。</p><pre class=" language-bash"><code class="language-bash">html <span class="token punctuation">{</span>  background: <span class="token comment" spellcheck="true">#fff;</span><span class="token punctuation">}</span>body <span class="token punctuation">{</span>  margin: auto<span class="token punctuation">;</span>  width: 50%<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="CSS-引号"><a href="#CSS-引号" class="headerlink" title="CSS 引号"></a>CSS 引号</h4><p>属性选择器和属性值用单引号，URI 的值不需要引号。</p><pre class=" language-bash"><code class="language-bash">/* 不推荐使用 */@import url<span class="token punctuation">(</span><span class="token string">"//www.google.com/css/maia.css"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>html <span class="token punctuation">{</span>  font-family: <span class="token string">"open sans"</span>, arial, sans-serif<span class="token punctuation">;</span><span class="token punctuation">}</span>/* 推荐使用 */@import url<span class="token punctuation">(</span>//www.google.com/css/maia.css<span class="token punctuation">)</span><span class="token punctuation">;</span>html <span class="token punctuation">{</span>  font-family: <span class="token string">'open sans'</span>, arial, sans-serif<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="CSS元规则"><a href="#CSS元规则" class="headerlink" title="CSS元规则"></a>CSS元规则</h3><h4 id="分段注释"><a href="#分段注释" class="headerlink" title="分段注释"></a>分段注释</h4><p>用注释把 CSS 分成各个部分。</p><pre class=" language-bash"><code class="language-bash">/* Header */<span class="token comment" spellcheck="true">#adw-header {}</span>/* Footer */<span class="token comment" spellcheck="true">#adw-footer {}</span>/* Gallery */.adw-gallery <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>坚持遵循代码规范。<br>写代码前先看看周围同事的代码，然后决定代码风格。<br>代码规范的意义在于提供一个参照物。这里提供了一份全局的规范，但是你也得参照公司内部的规范，否则阅读你代码的人会很痛苦。</p><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue生命周期--created和mounted的区别</title>
      <link href="/2017/04/20/vue-sheng-ming-zhou-qi-created-he-mounted-de-qu-bie/"/>
      <url>/2017/04/20/vue-sheng-ming-zhou-qi-created-he-mounted-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。例如，created 这个钩子在实例被创建之后被调用：<br><a id="more"></a></p><pre><code>var vm = new Vue({  data: {    a: 1  },  created: function () {    // `this` 指向 vm 实例    console.log(&#39;a is: &#39; + this.a)  }})// -&gt; &quot;a is: 1&quot;</code></pre><p>在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册js方法，可以让我们用自己注册的js方法控制整个大局，在这些事件响应方法中的this直接指向的是vue的实例。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p>#生命周期图示<br><img src="/imgs/vue/lifecycle.png" alt="&quot;生命周期&quot;"></p><p>#每个钩子函数都在啥时间触发<br>beforeCreate</p><blockquote><p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p></blockquote><p>created</p><blockquote><p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p></blockquote><p>beforeMount</p><blockquote><p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p></blockquote><p>mounted</p><blockquote><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</p></blockquote><p>beforeUpdate</p><blockquote><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p></blockquote><p>updated</p><blockquote><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p></blockquote><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。<br>该钩子在服务器端渲染期间不被调用。</p><p>beforeDestroy</p><blockquote><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p></blockquote><p>destroyed</p><blockquote><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p></blockquote><p>#vue生命周期的栗子</p><p> 注意触发vue的created事件以后,this便指向vue实例,这点很重要</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;vue生命周期&lt;/title&gt;        &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;test&quot; style=&quot;border: 1px black dashed;padding: 8px;&quot;&gt;            {{a}}        &lt;/div&gt;        &lt;div class=&quot;test2&quot; style=&quot;border: 1px red solid;margin-top: 10px;padding: 8px;&quot;&gt;            我是内容二        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var myVue = new Vue({                el: &quot;.test&quot;,                data: {                    a: &quot;我是内容,在控制台输入myVue.a=123456,可以改变我的值&quot;                },                created: function () {                     //在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher/事件回调。                    //但是还没有开始 DOM 编译，$el 还不存在,但是实例存在,即this.a存在,可打印出来 。                    console.log(&quot;建立&quot;);                },                beforeCompile: function () {                    console.log(&quot;未开始编译&quot;);                },                compiled: function () {                     //在编译结束后调用。此时所有的指令已生效，因而数据的变化将触发 DOM 更新。但是不担保 $el 已插入文档。                    console.log(&quot;编译完成&quot;);                },                ready: function () {                     //在编译结束和 $el 第一次插入文档之后调用，如在第一次 attached 钩子之后调用。注意必须是由 Vue 插入（如 vm.$appendTo() 等方法或指令更新）才触发 ready 钩子。                    console.log(&quot;一切准备好了&quot;);                },                attached :function () {  //myVue.$appendTo(&quot;.test2&quot;)暂时触发不了,不知道怎么解决                    //在 vm.$el 插入 DOM 时调用。必须是由指令或实例方法（如 $appendTo()）插入，直接操作 vm.$el 不会 触发这个钩子。                    console.log(&quot;插入DOM成功&quot;);                },                detached :function () { //触发事件 myVue.$destroy(true),其中参数true控制是否删除DOM节点或者myVue.$remove()                    //在 vm.$el 从 DOM 中删除时调用。必须是由指令或实例方法删除，直接操作 vm.$el 不会 触发这个钩子。                    console.log(&quot;删除DOM成功&quot;);                },                beforeDestroy: function () {  //触发方式,在console里面打myVue.$destroy();                    //在开始销毁实例时调用。此时实例仍然有功能。                    console.log(&quot;销毁前&quot;);                },                destroyed: function () {   //触发方式,在console里面打myVue.$destroy();其中myVue.$destroy(true)是删除DOM节点,会触发detached函数,但是实例仍然存在                    //在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，注意是解绑不是销毁,所有的子实例也已经被销毁。                    console.log(&quot;已销毁&quot;);                }        });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nodejs http的get,post请求</title>
      <link href="/2017/04/15/nodejs-de-http-qing-qiu-get-and-post/"/>
      <url>/2017/04/15/nodejs-de-http-qing-qiu-get-and-post/</url>
      
        <content type="html"><![CDATA[<h1 id="对于http的get，post请求的区别，我的理解有下面两点："><a href="#对于http的get，post请求的区别，我的理解有下面两点：" class="headerlink" title="对于http的get，post请求的区别，我的理解有下面两点："></a>对于http的get，post请求的区别，我的理解有下面两点：</h1><blockquote><p>1:get是向服务器索取数据的一种请求，而post是像服务器提交的一种请求。<br>2:post更加安全些，适合于登录，获取验证码等等。<br>3:post请求是将请求参数以form表单的形式post出去，而get请求参数直接加在path后面  例子 path=”callme/index.cfm/userService/command/search?”+”lat=123&amp;lon=123</p></blockquote><a id="more"></a><h1 id="http的get请求代码如下"><a href="#http的get请求代码如下" class="headerlink" title="http的get请求代码如下:"></a>http的get请求代码如下:</h1><pre><code>var http = require(&#39;http&#39;);var querystring = require(&#39;querystring&#39;);var options = {        host: &#39;xxx&#39;, // 这个不用说了, 请求地址        port:80,        path:path, // 具体路径, 必须以&#39;/&#39;开头, 是相对于host而言的        method: &#39;GET&#39;, // 请求方式, 这里以post为例        headers: { // 必选信息, 如果不知道哪些信息是必须的, 建议用抓包工具看一下, 都写上也无妨...            &#39;Content-Type&#39;: &#39;application/json&#39;        }    };    http.get(options, function(res) {        var resData = &quot;&quot;;        res.on(&quot;data&quot;,function(data){            resData += data;        });        res.on(&quot;end&quot;, function() {            callback(null,JSON.parse(resData));        });    })</code></pre><h1 id="http的post请求代码如下"><a href="#http的post请求代码如下" class="headerlink" title="http的post请求代码如下"></a>http的post请求代码如下</h1><pre><code>var http = require(&#39;http&#39;);var querystring = require(&#39;querystring&#39;);//json转换为字符串var data = querystring.stringify({    id:&quot;1&quot;,    pw:&quot;hello&quot;});var options = {    host: &#39;115.29.45.194&#39;,//    host:&#39;localhost&#39;,//    port: 14000,//    path: &#39;/v1?command=getAuthenticode&#39;,    path:&#39;/callme/index.cfm/userService/command/getAuthenticode/&#39;,    method: &#39;POST&#39;,    headers: {        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,        &#39;Content-Length&#39;: Buffer.byteLength(data)    }};var req = http.request(options, function(res) {    res.setEncoding(&#39;utf8&#39;);    res.on(&#39;data&#39;, function (chunk) {        console.log(&quot;body: &quot; + chunk);    });    res.on(&#39;end&#39;,function(chunk){        console.log(&quot;body: &quot; + chunk);    })});req.write(data);req.end();</code></pre><h1 id="http-get-options-callback"><a href="#http-get-options-callback" class="headerlink" title="http.get(options[, callback])"></a>http.get(options[, callback])</h1><p>发送简单Get请求，并响应</p><pre><code>var http=require(&#39;http&#39;);  //get 请求外网  http.get(&#39;http://www.gongjuji.net&#39;,function(req,res){      var html=&#39;&#39;;      req.on(&#39;data&#39;,function(data){          html+=data;      });      req.on(&#39;end&#39;,function(){          console.info(html);      });  });  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在vue中安装sass</title>
      <link href="/2017/04/08/sass-in-vue/"/>
      <url>/2017/04/08/sass-in-vue/</url>
      
        <content type="html"><![CDATA[<p>1，使用save会在package.json中自动添加。</p><blockquote><p>npm install node-sass  –save</p></blockquote><blockquote><p>npm install sass-loader  –save</p></blockquote><p>或者使用</p><blockquote><p>npm install sass-loader node-sass vue-style-loader –D </p></blockquote><a id="more"></a><p>2，如果失败，可以通过淘宝的npm镜像安装node-sass解决</p><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>  （安装淘宝镜像）<br>cnpm install node-sass  –save （使用淘宝镜像安装node-sass）</p><p>3，然后在webpack.base.conf.js中添加相关配置：</p><blockquote><p>{<br>    test: /.s[a|c]ss$/,<br>    loader: ‘style!css!sass’<br>}</p></blockquote><p> 当然，如果需要在vue文件style标签使用scss的话，需要声明一下：</p><blockquote> <style rel="stylesheet/scss" lang="scss"></blockquote></style></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Echarts3使用笔记(2)——标准柱状图使用实例</title>
      <link href="/2017/03/27/echarts3-bar-standard/"/>
      <url>/2017/03/27/echarts3-bar-standard/</url>
      
        <content type="html"><![CDATA[<p>本文主要是标准柱状图的使用方法以及一些常用配置的说明<br><a id="more"></a><br>引入文件</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;!-- 引入 ECharts 文件 --&gt;    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;</code></pre><p>在绘图前我们需要为 ECharts 准备一个具备高宽的 DOM 容器。</p><pre><code>&lt;body&gt;    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;    &lt;div id=&quot;main&quot; style=&quot;width: 800px;height:500px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>然后就可以通过 <a href="http://echarts.baidu.com/api.html#echarts.init" target="_blank" rel="noopener">echarts.init</a> 方法初始化一个 echarts 实例并通过 <a href="http://echarts.baidu.com/api.html#echartsInstance.setOption" target="_blank" rel="noopener">setOption</a> 方法生成一个简单的柱状图，下面是完整代码。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;标准柱状图实例&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/bootstrap.min.css&quot;&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/echarts3.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div id=&quot;demo1&quot; style=&quot;width: 800px;height:500px;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById(&#39;demo1&#39;));        // 指定图表的配置项和数据        var option = {                title : {                    text: &#39;某地区蒸发量和降水量&#39;,//大标题                    // textStyle: {                    //     color: &#39;#3491D0&#39;                    // },//标题颜色配置，源码已注释                    subtext: &#39;纯属虚构&#39;  // 小标题                },                tooltip : {                    trigger: &#39;axis&#39; //提示框组件。，可自定义                },                legend: {                    data:[&#39;蒸发量&#39;,&#39;降水量&#39;] //图例组件.图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。                },                toolbox: {                 //工具栏。内置有导出图片，数据视图，动态类型切换，数据区域缩放，重置五个工具。                    show : true,                    feature : {                        mark : {show: true},                        dataView : {show: true, readOnly: false},//数据视图                        magicType : {show: true, type: [&#39;line&#39;, &#39;bar&#39;]},//柱状很折线切换配置                        restore : {show: true},//重置                        saveAsImage : {show: true}//保存图片                    }                },                calculable : true,//是否显示拖拽用的手柄（手柄能拖拽调整选中范围）。默认false                xAxis : [                    {   //直角坐标系 grid 中的 x 轴，一般情况下单个 grid 组件最多只能放左右两个 x 轴                        type : &#39;category&#39;,                        data : [&#39;1月&#39;,&#39;2月&#39;,&#39;3月&#39;,&#39;4月&#39;,&#39;5月&#39;,&#39;6月&#39;,&#39;7月&#39;,&#39;8月&#39;,&#39;9月&#39;,&#39;10月&#39;,&#39;11月&#39;,&#39;12月&#39;],                        boundaryGap: true,                        name: &quot;月份&quot;                    //     axisLabel:{                    //             interval: &#39;auto&#39;,                    //             //rotate:45,倾斜度 -90 至 90 默认为0                    //             margin:8,                    //             textStyle:{                    //                  //data 的字体配置                    //                 fontWeight:&quot;normal&quot;,                    //                 color:&quot;#3491D0&quot;                    //             }                    //         },                    //         nameTextStyle:{                    //              //横坐标说明 的字体配置，本例中“月份”                    //             color:&quot;#3491D0&quot;,                    //             fontSize: 14                      //         }                     }                ],                yAxis : [                    {                        type : &#39;value&#39;,                        name: &#39;数量&#39;                        // axisLabel:{                        //         textStyle:{                        //             fontWeight:&quot;normal&quot;,                        //             color:&quot;#3491D0&quot;                        //         }                        //         },                        //      splitLine: {                        //       lineStyle: {                        //         color: &#39;#233e53&#39;,                                   //       }                         //     } ,                        //     nameTextStyle:{                        //         color:&quot;#3491D0&quot;,                        //         fontSize: 14                         //     }                      }                ],                series : [                    {                        name:&#39;蒸发量&#39;,                        type:&#39;bar&#39;,                        data:[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3],                        markPoint : {                            //蒸发量最大值，最小值                            data : [                                {type : &#39;max&#39;, name: &#39;最大值&#39;},                                {type : &#39;min&#39;, name: &#39;最小值&#39;}                            ]                        },                        markLine : {                            //平均值                            data : [                                {type : &#39;average&#39;, name: &#39;平均值&#39;}                            ]                        }                    },                    {                        name:&#39;降水量&#39;,                        type:&#39;bar&#39;,                        data:[2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3],                        markPoint : {                            data : [                                {name : &#39;年最高&#39;, value : 182.2, xAxis: 7, yAxis: 183, symbolSize:18},                                {name : &#39;年最低&#39;, value : 2.3, xAxis: 11, yAxis: 3}                            ]                        },                        markLine : {                            data : [                                {type : &#39;average&#39;, name : &#39;平均值&#39;}                            ]                        }                    }                ]        };        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>本例效果图：<br><img src="/imgs/echarts/2.png" alt="&quot;标准柱状图&quot;"></p><p>本文为原创文章，转载请注明出处<a href="https://xdlmr.github.io">https://xdlmr.github.io</a>,源码都放在<a href="https://github.com/xdlmr/Echarts3_demo" target="_blank" rel="noopener">github</a>，感兴趣的可以下载参考</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Echarts3使用笔记(1)——五分钟上手Echarts3</title>
      <link href="/2017/03/27/echarts3-five-minutes-learning/"/>
      <url>/2017/03/27/echarts3-five-minutes-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ECharts，缩写来自Enterprise Charts，商业级数据图表，是百度的一个开源的数据可视化工具，业界给予了很多赞誉。<br>之前做项目一直用的是echarts2做的，后来同事说Echarts3使用起来更方便，去官网一看，大部分配置和echarts2还是一样，只是用echarts3不在需要引入其他文件，不用其他的路径配置，直接引用一份echarts文件即可。而且echarts的界面更加友好，用户体验比以前更加完美。<br><a id="more"></a><br>本文源码都放在<a href="https://github.com/xdlmr/Echarts3_demo" target="_blank" rel="noopener">github</a>，感兴趣的可以下载参考</p><h1 id="获取-ECharts"><a href="#获取-ECharts" class="headerlink" title="获取 ECharts"></a>获取 ECharts</h1><p>你可以通过以下几种方式获取 ECharts。</p><ul><li><p>从<a href="http://echarts.baidu.com/download.html" target="_blank" rel="noopener">官网下载界面</a>选择你需要的版本下载，根据开发者功能和体积上的需求，我们提供了不同打包的下载，如果你在体积上没有要求，可以直接下载<a href="http://echarts.baidu.com/dist/echarts.min.js" target="_blank" rel="noopener">完整版本</a>。开发环境建议下载<a href="http://echarts.baidu.com/dist/echarts.js" target="_blank" rel="noopener">源代码</a>版本，包含了常见的错误提示和警告。</p></li><li><p>在 ECharts 的 <a href="https://github.com/echarts" target="_blank" rel="noopener">GitHub</a> 上下载最新的 release 版本，解压出来的文件夹里的 dist 目录里可以找到最新版本的 echarts 库。</p></li><li><p>通过 npm 获取 echarts，npm install echarts –save，详见<a href="http://echarts.baidu.com/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts" target="_blank" rel="noopener">“在 webpack 中使用 echarts”</a></p></li><li><p>cdn 引入，你可以在 <a href="https://cdnjs.com/libraries/echarts" target="_blank" rel="noopener">cdnjs</a>，<a href="https://npmcdn.com/echarts@latest/dist/" target="_blank" rel="noopener">npmcdn</a> 或者国内的 bootcdn 上找到 ECharts 的最新版本</p></li></ul><h1 id="引入-ECharts"><a href="#引入-ECharts" class="headerlink" title="引入 ECharts"></a>引入 ECharts</h1><p>ECharts 3 开始不再强制使用 AMD 的方式按需引入，代码里也不再内置 AMD 加载器。因此引入方式简单了很多，只需要像普通的 JavaScript 库一样用 script 标签引入。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;!-- 引入 ECharts 文件 --&gt;    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;</code></pre><h1 id="绘制一个简单的图表"><a href="#绘制一个简单的图表" class="headerlink" title="绘制一个简单的图表"></a>绘制一个简单的图表</h1><p>在绘图前我们需要为 ECharts 准备一个具备高宽的 DOM 容器。</p><pre><code>&lt;body&gt;    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>然后就可以通过 <a href="http://echarts.baidu.com/api.html#echarts.init" target="_blank" rel="noopener">echarts.init</a> 方法初始化一个 echarts 实例并通过 <a href="http://echarts.baidu.com/api.html#echartsInstance.setOption" target="_blank" rel="noopener">setOption</a> 方法生成一个简单的柱状图，下面是完整代码。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;ECharts&lt;/title&gt;    &lt;!-- 引入 echarts.js --&gt;    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById(&#39;main&#39;));        // 指定图表的配置项和数据        var option = {            title: {                text: &#39;ECharts 入门示例&#39;            },            tooltip: {},            legend: {                data:[&#39;销量&#39;]            },            xAxis: {                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]            },            yAxis: {},            series: [{                name: &#39;销量&#39;,                type: &#39;bar&#39;,                data: [5, 20, 36, 10, 10, 20]            }]        };        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这样你的第一个图表就诞生了！</p><p> <img src="/imgs/echarts/五分钟上手echarts3.png" alt="&quot;五分钟上手echarts&quot;"></p><p> 这是一个柱状图的实例，改变上面代码中series，type由bar改为line可生产折线图:</p><pre><code>series: [{                name: &#39;销量&#39;,                type: &#39;line&#39;,                data: [5, 20, 36, 10, 10, 20]            }]</code></pre><p> 本文参考 <a href="http://echarts.baidu.com/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts" target="_blank" rel="noopener">echarts官网案例</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>80% 应聘者都不及格的 JS 面试题</title>
      <link href="/2017/03/23/js-interview-question1/"/>
      <url>/2017/03/23/js-interview-question1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>共 5024 字，读完需 6 分钟，速读需 2 分钟，本文首发于知乎专栏<a href="https://zhuanlan.zhihu.com/feweekly" target="_blank" rel="noopener">前端周刊</a>。写在前面，笔者在做面试官这 2 年多的时间内，面试了数百个前端工程师，惊讶的发现，超过 80% 的候选人对下面这道题的回答情况连及格都达不到。这究竟是怎样神奇的一道面试题？他考察了候选人的哪些能力？对正在读本文的你有什么启示？且听我慢慢道来。<br><a id="more"></a></p><h1 id="不起眼的开始"><a href="#不起眼的开始" class="headerlink" title="不起眼的开始"></a>不起眼的开始</h1><p>招聘前端工程师，尤其是中高级前端工程师，扎实的 JS 基础绝对是必要条件，基础不扎实的工程师在面对前端开发中的各种问题时大概率会束手无策。在考察候选人 JS 基础的时候，我经常会提供下面这段代码，然后让候选人分析它实际运行的结果：</p><pre><code>for (var i = 0; i &lt; 5; i++) {    setTimeout(function() {       console.log(new Date, i);    }, 1000);}console.log(new Date, i);</code></pre><p>这段代码很短，只有 7 行，我想，能读到这里的同学应该不需要我逐行解释这段代码在做什么吧。候选人面对这段代码时给出的结果也不尽相同，以下是典型的答案：</p><ul><li>A. 20% 的人会快速扫描代码，然后给出结果：0,1,2,3,4,5；</li><li>B. 30% 的人会拿着代码逐行看，然后给出结果：5,0,1,2,3,4；</li><li>C. 50% 的人会拿着代码仔细琢磨，然后给出结果：5,5,5,5,5,5；</li></ul><p>只要你对 JS 中同步和异步代码的区别、变量作用域、闭包等概念有正确的理解，就知道正确答案是 C，代码的实际输出是：</p><ul><li>2017-03-18T00:43:45.873Z 5</li><li>2017-03-18T00:43:46.866Z 5</li><li>2017-03-18T00:43:46.868Z 5</li><li>2017-03-18T00:43:46.868Z 5</li><li>2017-03-18T00:43:46.868Z 5</li><li>2017-03-18T00:43:46.868Z 5</li></ul><p>接下来我会追问：如果我们约定，用箭头表示其前后的两次输出之间有 1 秒的时间间隔，而逗号表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？会有下面两种答案：</p><ul><li>A. 60% 的人会描述为：5 -&gt; 5 -&gt; 5 -&gt; 5 -&gt; 5，即每个 5 之间都有 1 秒的时间间隔；</li><li>B. 40% 的人会描述为：5 -&gt; 5,5,5,5,5，即第 1 个 5 直接输出，1 秒之后，输出 5 个 5；</li><li>这就要求候选人对 JS 中的定时器工作机制非常熟悉，循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B。</li></ul><p>如果到这里算是及格的话，100 个人参加面试只有 20 人能及格，读到这里的同学可以仔细思考，你及格了么？</p><h1 id="追问-1：闭包"><a href="#追问-1：闭包" class="headerlink" title="追问 1：闭包"></a>追问 1：闭包</h1><p>如果这道题仅仅是考察候选人对 JS 异步代码、变量作用域的理解，局限性未免太大，接下来我会追问，如果期望代码的输出变成：5 -&gt; 0,1,2,3,4，该怎么改造代码？熟悉闭包的同学很快能给出下面的解决办法：</p><pre><code> for (var i = 0; i &lt; 5; i++) {    (function(j) {  // j = i        setTimeout(function() {            console.log(new Date, j);        }, 1000);    })(i); }console.log(new Date, i);</code></pre><p>巧妙的利用 IIFE（Immediately Invoked Function Expression：声明即执行的函数表达式）来解决闭包造成的问题，确实是不错的思路，但是初学者可能并不觉得这样的代码很好懂，至少笔者初入门的时候这里琢磨了一会儿才真正理解。</p><p>有没有更符合直觉的做法？答案是有，我们只需要对循环体稍做手脚，让负责输出的那段代码能拿到每次循环的 i 值即可。该怎么做呢？利用 JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征，不难改造出下面的代码：</p><pre><code> var output = function (i) {    setTimeout(function() {        console.log(new Date, i);    }, 1000);};for (var i = 0; i &lt; 5; i++) {    output(i);  // 这里传过去的 i 值被复制了} console.log(new Date, i);</code></pre><p>能给出上述 2 种解决方案的候选人可以认为对 JS 基础的理解和运用是不错的，可以各加 10 分。当然实际面试中还有候选人给出如下的代码：</p><pre><code> for (let i = 0; i &lt; 5; i++) {    setTimeout(function() {        console.log(new Date, i);    }, 1000);} console.log(new Date, i);</code></pre><p>细心的同学会发现，这里只有个非常细微的变动，即使用 ES6 块级作用域（Block Scope）中的 let 替代了 var，但是代码在实际运行时会报错，因为最后那个输出使用的 i 在其所在的作用域中并不存在，i 只存在于循环内部。</p><p>能想到 ES6 特性的同学虽然没有答对，但是展示了自己对 ES6 的了解，可以加 5 分，继续进行下面的追问。</p><h1 id="追问-2：ES6"><a href="#追问-2：ES6" class="headerlink" title="追问 2：ES6"></a>追问 2：ES6</h1><p>有经验的前端同学读到这里可能有些不耐烦了，扯了这么多，都是他知道的内容，先别着急，挑战的难度会继续增加。</p><p>接着上文继续追问：如果期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5（这里使用大概，是为了避免钻牛角尖的同学陷进去，因为 JS 中的定时器触发时机有可能是不确定的，具体可参见 How Javascript Timers Work）。</p><p>看到这里，部分同学会给出下面的可行解：</p><pre><code> for (var i = 0; i &lt; 5; i++) {    (function(j) {        setTimeout(function() {            console.log(new Date, j);       }, 1000 * j);  // 这里修改 0~4 的定时器时间    })(i);}setTimeout(function() { // 这里增加定时器，超时设置为 5 秒   console.log(new Date, i);}, 1000 * i);</code></pre><p>不得不承认，这种做法虽粗暴有效，但是不算是能额外加分的方案。如果把这次的需求抽象为：在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情，代码该怎么组织？聪明的你是不是想起了什么？对，就是 Promise。</p><p>可能有的同学会问，不就是在控制台输出几个数字么？至于这样杀鸡用牛刀？你要知道，面试官真正想考察的是候选人是否具备某种能力和素质，因为在现代的前端开发中，处理异步的代码随处可见，熟悉和掌握异步操作的流程控制是成为合格开发者的基本功。</p><p>顺着下来，不难给出基于 Promise 的解决方案（既然 Promise 是 ES6 中的新特性，我们的新代码使用 ES6 编写是不是会更好？如果你这么写了，大概率会让面试官心生好感）：</p><pre><code>const tasks = [];for (var i = 0; i &lt; 5; i++) {   // 这里 i 的声明不能改成 let，如果要改该怎么做？    ((j) =&gt; {        tasks.push(new Promise((resolve) =&gt; {            setTimeout(() =&gt; {                console.log(new Date, j);                resolve();  // 这里一定要 resolve，否则代码不会按预期 work            }, 1000 * j);   // 定时器的超时时间逐步增加        }));    })(i);}Promise.all(tasks).then(() =&gt; {    setTimeout(() =&gt; {        console.log(new Date, i);    }, 1000);   // 注意这里只需要把超时设置为 1 秒});</code></pre><p>相比而言，笔者更倾向于下面这样看起来更简洁的代码，要知道编程风格也是很多面试官重点考察的点，代码阅读时的颗粒度更小，模块化更好，无疑会是加分点。</p><pre><code>const tasks = []; // 这里存放异步操作的 Promiseconst output = (i) =&gt; new Promise((resolve) =&gt; {    setTimeout(() =&gt; {        console.log(new Date, i);        resolve();    }, 1000 * i);});// 生成全部的异步操作for (var i = 0; i &lt; 5; i++) {    tasks.push(output(i));}// 异步操作完成之后，输出最后的 iPromise.all(tasks).then(() =&gt; {    setTimeout(() =&gt; {        console.log(new Date, i);    }, 1000);});</code></pre><p>读到这里的同学，恭喜你，你下次面试遇到类似的问题，至少能拿到 80 分。</p><p>我们都知道使用 Promise 处理异步代码比回调机制让代码可读性更高，但是使用 Promise 的问题也很明显，即如果没有处理 Promise 的 reject，会导致错误被丢进黑洞，好在新版的 Chrome 和 Node 7.x 能对未处理的异常给出 Unhandled Rejection Warning，而排查这些错误还需要一些特别的技巧（浏览器、Node.js）。</p><h1 id="追问-3：ES7"><a href="#追问-3：ES7" class="headerlink" title="追问 3：ES7"></a>追问 3：ES7</h1><p>既然你都看到这里了，那就再坚持 2 分钟，接下来的内容会让你明白你的坚持是值得的。</p><p>多数面试官在决定聘用某个候选人之前还需要考察另外一项重要能力，即技术自驱力，直白的说就是候选人像有内部的马达在驱动他，用漂亮的方式解决工程领域的问题，不断的跟随业务和技术变得越来越牛逼，究竟什么是牛逼？建议阅读程序人生的这篇剖析。</p><p>回到正题，既然 Promise 已经被拿下，如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？你是否能够根据自己目前掌握的知识给出答案？请在这里暂停 1 分钟，思考下。</p><p>下面是笔者给出的参考代码：</p><pre><code>// 模拟其他语言中的 sleep，实际上可以是任何异步操作const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; {    setTimeout(resolve, timeountMS);});(async () =&gt; {  // 声明即执行的 async 函数表达式    for (var i = 0; i &lt; 5; i++) {        await sleep(1000);        console.log(new Date, i);    }    await sleep(1000);    console.log(new Date, i);})();</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感谢你花时间读到这里，相信你收获的不仅仅是用 JS 精确控制代码输出的各种技巧，更是对于前端工程师的成长期许：扎实的语言基础、与时俱进的能力、强大技术自驱力。</p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p>本文转自<a href="https://juejin.im/post/58cf180b0ce4630057d6727c" target="_blank" rel="noopener">https://juejin.im/post/58cf180b0ce4630057d6727c</a>,纯属个人喜欢该文章，并非用于商业，若有侵权行为请<a href="mailto:m13259482119@163.com" target="_blank" rel="noopener">联系博主</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 笔试面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo-next主题的多说配置，添加评论功能</title>
      <link href="/2017/03/21/duoshuo-config/"/>
      <url>/2017/03/21/duoshuo-config/</url>
      
        <content type="html"><![CDATA[<h1 id="next主题配置多说评论"><a href="#next主题配置多说评论" class="headerlink" title="next主题配置多说评论"></a>next主题配置多说评论</h1><p>在hexo+github搭建的静态博客中假如第三方服务-多说，可以使博客增加文章评论功能，实现博主与读者之间的交互。</p> <a id="more"></a><p>使用多说前需要先在 <a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a>创建一个站点。具体步骤如下：</p><ul><li>登录后在首页选择 “我要安装”。</li><li>创建站点，填写站点相关信息。多说域名这一栏填写的即是你的duoshuo_shortname，如图：<br><img src="/imgs/duoshuo.png" alt="&quot;创建多说站点&quot;"></li><li>点击创建后进入多说界面：<br><img src="/imgs/duoshuo1.png" alt="&quot;创建多说站点&quot;"><br>我们替换data-thread-key、data-title、data-url字段值：<br>下面是修改后的代码：<br> <code>`</code> <!-- 多说评论框 start --><div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div></li></ul><!-- 多说评论框 end --><!-- 多说公共JS代码 start (一个网页只需插入一次) --><p><script type="text/javascript"><br>var duoshuoQuery = {short_name:”maorli”};<br>  (function() {<br>    var ds = document.createElement(‘script’);<br>    ds.type = ‘text/javascript’;ds.async = true;<br>    ds.src = (document.location.protocol == ‘https:’ ? ‘https:’ : ‘http:’) + ‘//static.duoshuo.com/embed.js’;<br>    ds.charset = ‘UTF-8’;<br>    (document.getElementsByTagName(‘head’)[0]<br>     || document.getElementsByTagName(‘body’)[0]).appendChild(ds);<br>  })();<br>  </script><br><!-- 多说公共JS代码 end --></p><pre><code>* 复制此代码，替换comments.swig文件内容 ，打开   ~/blog/themes/next/layout/_partials/comments.swig文件，替换其内容。* 配置/blog/themes/next/_config.yml文件</code></pre><p> duoshuo_shortname: maorli<br> <code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Next </tag>
            
            <tag> 多说 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS3伪类选择器</title>
      <link href="/2017/02/22/css3-wei-lei-xuan-ze-qi/"/>
      <url>/2017/02/22/css3-wei-lei-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<p>本文主要针对伪类选择器的使用进行说明，伪类选择器可以动态的对页面的内容进行样式化，目前有16个强大的新伪类选择器被列入最新的W3C规范中。<br><a id="more"></a></p><h2 id="早期伪类选择器"><a href="#早期伪类选择器" class="headerlink" title="早期伪类选择器"></a>早期伪类选择器</h2><p>CSS1时期(1996年)就被纳入规范中的伪类选择器,也是我们最常用到的选择器,这些选择器最常被用到 “a” 标签中。</p><pre class=" language-bash"><code class="language-bash">:link:visited:hover:active</code></pre><ol><li>:link 为链接平常的状态。</li><li>:visited 链接被访问过后的状态。</li><li>:hover 鼠标放在链接上时的状态。</li><li>:active 鼠标被按下，还未松开鼠标时的状态。</li></ol><h2 id="CSS2时期引入的伪类选择器"><a href="#CSS2时期引入的伪类选择器" class="headerlink" title="CSS2时期引入的伪类选择器"></a>CSS2时期引入的伪类选择器</h2><p>CSS2规范实在1998年5月发布的。</p><pre class=" language-bash"><code class="language-bash">:lang:first-child</code></pre><ol><li>:lang 指明一个文档所使用的语言。类似于</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span></code></pre><ol start="2"><li>:first-child 指明父元素下的一组同级元素中的第一个。</li></ol><h2 id="CSS3时代"><a href="#CSS3时代" class="headerlink" title="CSS3时代"></a>CSS3时代</h2><h3 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h3><h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><pre class=" language-bash"><code class="language-bash">:root</code></pre><p>:root 伪类选择器表示页面的根元素。即 &lt; html &rt; 元素。</p><pre class=" language-bash"><code class="language-bash">:nth-child<span class="token punctuation">(</span>n<span class="token punctuation">)</span></code></pre><h4 id="nth-child-n"><a href="#nth-child-n" class="headerlink" title="nth-child(n)"></a>nth-child(n)</h4><p>:nth-child(n) 伪类选择器表示第n个子元素。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>ul<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>1<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-child<span class="token punctuation">(</span>1<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>2<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-child<span class="token punctuation">(</span>2<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>3<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-child<span class="token punctuation">(</span>3<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>4<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-child<span class="token punctuation">(</span>4<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>5<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-child<span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><p>li:nth-child(even) 代表代码中偶数行，也可以用 li:nth-child(2n)<br>li:nth-child(odd) 代表代码中奇数行，也可以用 li:nth-child(2n+1)</p><ul class="myli_nth"><li>列表第1行</li><li>列表第2行</li><li>列表第3行</li><li>列表第4行</li><li>列表第5行</li></ul><p>可以看出，偶数行与奇数行表现的颜色不同。</p><p>代码如下:</p><p>html代码</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>ul class<span class="token operator">=</span><span class="token string">"myli_nth"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>列表第1行<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>列表第2行<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>列表第3行<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>列表第4行<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>列表第5行<span class="token operator">&lt;</span>/li<span class="token operator">></span><span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><p>CSS代码</p><pre class=" language-bash"><code class="language-bash">.myli_nth li:nth-child<span class="token punctuation">(</span>odd<span class="token punctuation">)</span><span class="token punctuation">{</span>    background: <span class="token comment" spellcheck="true">#FFD700;</span><span class="token punctuation">}</span>.myli_nth li:nth-child<span class="token punctuation">(</span>even<span class="token punctuation">)</span><span class="token punctuation">{</span>    background: <span class="token comment" spellcheck="true">#BFEFFF;</span><span class="token punctuation">}</span></code></pre><p>假如要选中一个列表的前3项，我们可以写</p><pre class=" language-bash"><code class="language-bash">li:nth-child<span class="token punctuation">(</span>-n+3<span class="token punctuation">)</span></code></pre><h4 id="nth-last-child-n"><a href="#nth-last-child-n" class="headerlink" title="nth-last-child(n)"></a>nth-last-child(n)</h4><p>:nth-last-child(n) 和 nth-child(n) 用法完全相同，唯一不同的就是 nth-child(n) 是从第一个开始往下算。而 :nth-last-child(n)是从最后一个往前倒着算。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>ul<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>1<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-last-child<span class="token punctuation">(</span>5<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>2<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-last-child<span class="token punctuation">(</span>4<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>3<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-last-child<span class="token punctuation">(</span>3<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>4<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-last-child<span class="token punctuation">(</span>2<span class="token punctuation">)</span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>5<span class="token operator">&lt;</span>/li<span class="token operator">></span> ------- li:nth-last-child<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><h4 id="nth-of-type-n"><a href="#nth-of-type-n" class="headerlink" title="nth-of-type(n)"></a>nth-of-type(n)</h4><p>:nth-of-type(n) 只针对特定类型的元素应用样式。</p><p>例如：我们需要使用更大的字体来表示文章的第一个段落：</p><pre class=" language-bash"><code class="language-bash">article p:nth-of-type<span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token punctuation">{</span>font-size: 1.5em<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="nth-last-of-type-n"><a href="#nth-last-of-type-n" class="headerlink" title="nth-last-of-type(n)"></a>nth-last-of-type(n)</h4><p>同 :nth-of-type(n) 原理一样，唯一不同的就是 :nth-last-of-type(n) 是从后往前倒序工作。</p><h4 id="first-of-type"><a href="#first-of-type" class="headerlink" title="first-of-type"></a>first-of-type</h4><p>相当于 :nth-of-type(1)</p><h4 id="last-of-type"><a href="#last-of-type" class="headerlink" title="last-of-type"></a>last-of-type</h4><p>相当于 :nth-last-of-type(1)</p><h4 id="only-of-type"><a href="#only-of-type" class="headerlink" title="only-of-type"></a>only-of-type</h4><p>这个伪类用来选择父元素下只有唯一一个某种类型的元素。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>第1个段落<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>第2个段落<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>第3个段落<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><p>如果上面一段代码有这样一个css：</p><pre class=" language-bash"><code class="language-bash">p:only-of-type<span class="token punctuation">{</span>color: red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>那么结果是只有第三个段落的字体颜色会变红。因为只有第三个段落的父元素div有唯一的一个p元素。</p><h4 id="last-child"><a href="#last-child" class="headerlink" title="last-child"></a>last-child</h4><p>:first-child 代表的是第一个子元素。<br>:last-child 代表的是最后一个子元素。</p><h4 id="only-child"><a href="#only-child" class="headerlink" title="only-child"></a>only-child</h4><p>如果一个元素是它父元素下的唯一子元素，就可以使用 :only-child 来选中该元素。</p><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>:empty 这个伪类选择器用来选择没有子元素和内容的元素。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#result:empty{</span>    background-color: <span class="token comment" spellcheck="true">#f00;</span><span class="token punctuation">}</span></code></pre><p>我们可以使用上边的CSS代码来表示用户搜索结果为空的情况。</p><h3 id="目标伪类"><a href="#目标伪类" class="headerlink" title="目标伪类"></a>目标伪类</h3><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>:target 这个伪类允许我们基于url对页面上的元素设置样式。如果url中有一个标识符(即以’#’开头的字符串)，那么 :target 就可以对以该标识符为id的元素进行样式设置。</p><p>如果有这样一个url：</p><pre class=" language-bash"><code class="language-bash">http://www.test.com/test<span class="token comment" spellcheck="true">#summary</span></code></pre><p>id属性为summary的区域可以这样来写</p><pre class=" language-bash"><code class="language-bash">:target<span class="token punctuation">{</span>    background-color: <span class="token comment" spellcheck="true">#f00;</span><span class="token punctuation">}</span></code></pre><h3 id="元素状态伪类"><a href="#元素状态伪类" class="headerlink" title="元素状态伪类"></a>元素状态伪类</h3><h4 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h4><p>:enabled 表示元素可编辑状态时的样式。例如：</p><pre class=" language-bash"><code class="language-bash">input:enabled<span class="token punctuation">{</span>    background-color: green<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>表示input输入框在可编辑状态下时背景为绿色。</p><h4 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h4><p>:disabled 表示元素在不可编辑状态时的样式。例如：</p><pre class=" language-bash"><code class="language-bash">input:disabled<span class="token punctuation">{</span>    background-color: red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>表示input输入框在可编辑状态下时背景为红色。</p><h4 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h4><p>:checked 表示单选框或多选框在选中状态下时的样式。</p><pre class=" language-bash"><code class="language-bash">input<span class="token punctuation">[</span>type<span class="token operator">=</span>checkbox<span class="token punctuation">]</span>:checked<span class="token punctuation">{</span>    font-weight: bold<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>表示多选框在选中状态下时，变为粗体。</p><h3 id="否定伪类选择器"><a href="#否定伪类选择器" class="headerlink" title="否定伪类选择器"></a>否定伪类选择器</h3><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>:not 选择器表示除指定元素外的所有元素。</p><pre class=" language-bash"><code class="language-bash">:not<span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">{</span>    background-color: blue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>表示页面上除了 header 元素以外的所有元素。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般的项目中，可能我们用到的伪类选择器就那么几个，但是其他不常用的选择器还是需要稍微了解一下，万一在用到的时候，不至于一时想不起来。</p><script type="text/javascript" src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript" src="/js/my/css3_2.js"></script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS3新增属性(过渡、背景裁剪、动画、CSS变换)</title>
      <link href="/2017/02/20/css3-xin-zeng-shu-xing/"/>
      <url>/2017/02/20/css3-xin-zeng-shu-xing/</url>
      
        <content type="html"><![CDATA[<p>本文简述CSS3的过渡效果<a href="http://www.runoob.com/css3/css3-transitions.html" target="_blank" rel="noopener">transition</a>、动画<a href="http://www.runoob.com/css3/css3-animations.html" target="_blank" rel="noopener">animation</a>、背景相关操作<a href="http://www.runoob.com/css3/css3-backgrounds.html" target="_blank" rel="noopener">background</a>等。</p><a id="more"></a><h2 id="CSS3过渡效果transition"><a href="#CSS3过渡效果transition" class="headerlink" title="CSS3过渡效果transition"></a>CSS3过渡效果transition</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><div class="trans_div"><br>    请把鼠标放在该区域<br></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>html代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"trans_div"</span><span class="token operator">></span>请把鼠标放在该区域<span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><p>css样式：</p><pre class=" language-bash"><code class="language-bash">.trans_div<span class="token punctuation">{</span>    width: 100px<span class="token punctuation">;</span>    height: 100px<span class="token punctuation">;</span>    background: <span class="token comment" spellcheck="true">#ff0000;</span>    color: <span class="token comment" spellcheck="true">#ffffff;</span>    transition: width 2s , background 2s<span class="token punctuation">;</span>    -webkit-transition: width 2s , background 2s<span class="token punctuation">;</span>    -ms-transition: width 2s , background 2s<span class="token punctuation">;</span>    -moz-transition: width 2s , background 2s<span class="token punctuation">;</span><span class="token punctuation">}</span>.trans_div:hover<span class="token punctuation">{</span>    width: 300px<span class="token punctuation">;</span>    background: <span class="token comment" spellcheck="true">#0000ff;</span><span class="token punctuation">}</span></code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>trans_div这个class定义了div的过渡属性，width过渡时间为2s，background过渡时间为2s。之后在鼠标放上去hover的状态下，触发transition。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>transition包含4个过渡属性</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">transition-property</td><td style="text-align:left">定义应用过渡的 CSS 属性的名称。</td></tr><tr><td style="text-align:left">transition-duration</td><td style="text-align:left">定义实现过渡效果需要花费的时间。默认是 0。</td></tr><tr><td style="text-align:left">transition-timing-function</td><td style="text-align:left">规定过渡效果的时间曲线。默认是 “ease”。</td></tr><tr><td style="text-align:left">transition-delay</td><td style="text-align:left">规定过渡效果何时开始。默认是 0。</td></tr></tbody></table><h2 id="CSS变换transform"><a href="#CSS变换transform" class="headerlink" title="CSS变换transform"></a>CSS变换transform</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><div class="transform_div"><br>    div旋转<br></div><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>html代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"transform_div"</span><span class="token operator">></span>div旋转<span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><p>css代码：</p><pre class=" language-bash"><code class="language-bash">.transform_div<span class="token punctuation">{</span>    width: 100px<span class="token punctuation">;</span>    height: 100px<span class="token punctuation">;</span>    background: <span class="token comment" spellcheck="true">#00ff00;</span>    transform: rotate3d<span class="token punctuation">(</span>1,2,3,30deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>transform使元素实现了2D、3D的翻转、拉伸、缩放、移动、倾斜等效果。</p><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h3><p>transition包含2D和3D两种效果，属性太多了，懒得写了，请点击下面链接自行看。。。实在不好意思。。。<br>链接为css3菜鸟教程内容:<a href="http://www.runoob.com/css3/css3-2dtransforms.html" target="_blank" rel="noopener">2d效果</a><br>链接为css3菜鸟教程内容:<a href="http://www.runoob.com/css3/css3-3dtransforms.html" target="_blank" rel="noopener">3d效果</a></p><h2 id="盒阴影box-shadow"><a href="#盒阴影box-shadow" class="headerlink" title="盒阴影box-shadow"></a>盒阴影box-shadow</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><div class="shadow_div"><br>    阴影<br></div><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>html代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"shadow_div"</span><span class="token operator">></span>阴影<span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><p>css代码：</p><pre class=" language-bash"><code class="language-bash">.shadow_div<span class="token punctuation">{</span>    width: 100px<span class="token punctuation">;</span>    height: 100px<span class="token punctuation">;</span>    border: 2px solid <span class="token comment" spellcheck="true">#fff;</span>    border-radius: 5px<span class="token punctuation">;</span>    box-shadow: 10px 10px 5px <span class="token comment" spellcheck="true">#888888;</span><span class="token punctuation">}</span></code></pre><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><p>box-shadow可以为img，div等添加阴影效果，使其出现层次感。border-radius实现边框圆角效果。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class=" language-bash"><code class="language-bash">box-shadow: h-shadow v-shadow blur spread color inset<span class="token punctuation">;</span></code></pre><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">h-shadow</td><td style="text-align:left">必写。水平阴影的位置。允许负值</td></tr><tr><td style="text-align:left">v-shadow</td><td style="text-align:left">必写。垂直阴影的位置。允许负值</td></tr><tr><td style="text-align:left">blur</td><td style="text-align:left">可选。模糊距离</td></tr><tr><td style="text-align:left">spread</td><td style="text-align:left">可选。阴影的大小</td></tr><tr><td style="text-align:left">color</td><td style="text-align:left">可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表</td></tr><tr><td style="text-align:left">inset</td><td style="text-align:left">可选。从外层的阴影（开始时）改变阴影内侧阴影</td></tr></tbody></table><h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><div class="animation_div">CSS3动画</div><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>html代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div class<span class="token operator">=</span><span class="token string">"animation_div"</span><span class="token operator">></span>CSS3动画<span class="token operator">&lt;</span>/div<span class="token operator">></span></code></pre><p>css代码：</p><pre class=" language-bash"><code class="language-bash">.animation_div<span class="token punctuation">{</span>    position: relative<span class="token punctuation">;</span>    width: 100px<span class="token punctuation">;</span>    height: 100px<span class="token punctuation">;</span>    background: <span class="token comment" spellcheck="true">#ffff00;</span>    animation: myanimate 4s infinite<span class="token punctuation">;</span><span class="token punctuation">}</span>@keyframes myanimate<span class="token punctuation">{</span>    0% <span class="token punctuation">{</span>        background: <span class="token comment" spellcheck="true">#ffff00;</span>        left: 0px<span class="token punctuation">;</span>        transform: rotate<span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    25% <span class="token punctuation">{</span>        background: <span class="token comment" spellcheck="true">#00ff00;</span>        left: 150px<span class="token punctuation">;</span>        transform: rotate<span class="token punctuation">(</span>90deg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    50% <span class="token punctuation">{</span>        background: <span class="token comment" spellcheck="true">#00ffff;</span>        left: 300px<span class="token punctuation">;</span>        transform: rotate<span class="token punctuation">(</span>180deg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    75% <span class="token punctuation">{</span>        background: <span class="token comment" spellcheck="true">#00ff00;</span>        left: 150px<span class="token punctuation">;</span>        transform: rotate<span class="token punctuation">(</span>270deg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    100% <span class="token punctuation">{</span>        background: <span class="token comment" spellcheck="true">#ffff00;</span>        left: 0px<span class="token punctuation">;</span>        transform: rotate<span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>animate用来创建css动画效果，使用时，先给动画起个名字，然后用 @keyframes 语法来定义该动画的效果展示，动画效果开始为0%状态，结束为100%状态。根据不同时间节点，来定义该动画在不同节点上的展示效果。</p><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">@keyframes</td><td style="text-align:left">规定动画在不同时间段的展示效果</td></tr><tr><td style="text-align:left">animation</td><td style="text-align:left">所有动画属性的简写属性，除了 animation-play-state 属性。</td></tr><tr><td style="text-align:left">animation-name</td><td style="text-align:left">规定 @keyframes 动画的名称。</td></tr><tr><td style="text-align:left">animation-duration</td><td style="text-align:left">规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td></tr><tr><td style="text-align:left">animation-timing-function</td><td style="text-align:left">规定动画的速度曲线。默认是 “ease”。</td></tr><tr><td style="text-align:left">animation-delay</td><td style="text-align:left">规定动画何时开始。默认是 0。</td></tr><tr><td style="text-align:left">animation-iteration-count</td><td style="text-align:left">规定动画被播放的次数。默认是 1。无限循环为 infinite。</td></tr><tr><td style="text-align:left">animation-direction</td><td style="text-align:left">规定动画何时开始。默认是 0。</td></tr><tr><td style="text-align:left">animation-play-state</td><td style="text-align:left">规定动画是否正在运行或暂停。默认是 “running”。</td></tr></tbody></table><script type="text/javascript" src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript" src="/js/my/css3_1.js"></script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>成为一名优秀的web前端工程师都需要做些什么？</title>
      <link href="/2016/08/31/how-to-become-a-good-web-front-end-engineer/"/>
      <url>/2016/08/31/how-to-become-a-good-web-front-end-engineer/</url>
      
        <content type="html"><![CDATA[<p>程序设计之道无远弗届，御晨风而返。———— 杰佛瑞 · 詹姆士</p><p>我所遇到的前端程序员分两种：<br>    第一种一直在问：如何学习前端？<br>    第二种总说：前端很简单，就那么一点东西。</p><p>我从没有听到有人问：如何做一名优秀、甚至卓越的WEB前端工程师。<br>如果成为一名优秀的web前端工程师（前端攻城师）？</p> <a id="more"></a><p>何为：前端工程师？<br>前端工程师，也叫Web前端开发工程师。他是随着web发展，细分出来的行业。<br>Web前端开发技术主要包括三个要素：HTML、CSS和JavaScript！<br>它要求前端开发工程师不仅要掌握基本的Web前端开发技术，网站性能优化、SEO和服务器端的基础知识，而且要学会运用各种工具进行辅助开发以及理论层面的知识，包括代码的可维护性、组件的易用性、分层语义模板和浏览器分级支持等。<br>随着近两三年来RIA（Rich Internet Applications的缩写，中文含义为：丰富的因特网应用程序）的流行和普及带来的诸如：Flash/Flex，Silverlight、XML和服务器端语言（PHP、ASP.NET，JSP、Python）等语言，前端开发工程师也需要掌握。<br>前端开发的入门门槛其实很低，与服务器端语言先慢后快的学习曲线相比，前端开发的学习曲线是先快后慢。<br>HTML 甚至不是一门语言，他仅仅是简单的标记语言！<br>CSS 只是无类型的样式修饰语言。当然可以勉强算作弱类型语言。<br>Javascript 的基础部分相对来说不难，入手还算快。</p><p>也正因为如此，前端开发领域有很多自学成“才”的同行，但大多数人都停留在会用的阶段，因为后面的学习曲线越来越陡峭，每前进一步都很难。<br>Web前端技术有一些江湖气，知识点过于琐碎，技术价值观的博弈也难分伯仲，即全局的系统的知识结构并未成体系，这些因素也客观上影响了“正统“前端技术的沉淀！而且各种“奇技淫巧”被滥用，前端技术知识的传承也过于泛泛，新人难看清时局把握主次。因此，前端技术领域，为自己觅得一个靠谱的师兄，重要性要盖过项目、团队、公司、甚至薪水。</p><p>另一方面，正如前面所说，前端开发是个非常新的职业，对一些规范和最佳实践的研究都处于探索阶段。<br>总有新的灵感和技术不时闪现出来，例如CSS sprite、负边距布局、栅格布局等；<br>各种JavaScript框架层出不穷，为整个前端开发领域注入了巨大的活力；<br>浏览器大战也越来越白热化，跨浏览器兼容方案依然是五花八门。<br>为了满足“高可维护性”的需要，需要更深入、更系统地去掌握前端知识，这样才可能创建一个好的前端架构，保证代码的质量。</p><p>随着手持设备的迅猛发展，带动了 HTML5行业标准的快速发展。web领域的技术，大概有10年都没有大的更新了！<br>现在市场很需要优秀的、高级的前端工程师。<br>一方面是因为这是一个比较新的细分行业，而且前端程序员大都自学一部分，知识结构不系统；另一方面，大学里面没有这种课程，最最重要的是：北大青鸟这类培训机构也没有专门的前端工程师的培训课程！！</p><p>吴亮在《JavaScript 王者归来》第一张的序里面说：大多数程序员认为 Javascript 过于简陋，只适合一些网页上面花哨的表现，所以不愿花费精力去学习，或者以为不学习就能掌握。<br>实际上，一门语言是否脚本语言，往往是她的设计目标决定，简单与复杂并不是区分脚本语言和非脚本语言的标准。<br>事实上，在脚本语言里面，Javascript 属于相当复杂的一门语言，他的复杂度即使放在非脚本语言中来衡量，也是一门相当复杂的语言！<br>Javascript 的复杂度不逊色于 Perl 和 Python！</p><p>如何学习前端知识？<br>我们生活在一个充满规则的宇宙里面。社会秩序按照规则运行，计算机语言几乎全部是规则的集合。计算机前辈们定义规则，规则约束我们，我们用规则控制数据。大部分时候，对数据的合理控制，来自于你对规则的掌握。</p><p>学习 HTML，CSS 应该先跟着书仔细、扎实的学一遍。然后就需要做大量的练习，做各种常规的、奇怪的、大量的布局练习来捆固、理解自己的知识。<br>而学习 Javascript 首先要知道这门语言可以做什么，不能做什么，擅长做什么，不擅长做什么！<br>如果你只想当一个普通的前端程序员，你只需要记住大部分 Javascript 函数，做一些练习就可以了。<br>如果你想当深入了解Javascript，你需要了解 Javascript 的原理，机制。需要知道他们的本源，需要深刻了解 Javascript 基于对象的本质。<br>还需要 深刻了解 浏览器宿主 下 的 Javascript 的行为、特性。</p><p>因为历史原因，Javascript一直不被重视，有点像被收养的一般！ 所以他有很多缺点，各个宿主环境下的行为不统一、内存溢出问题、执行效率低下等问题。<br>作为一个优秀的前端工程师还需要深入了解、以及学会处理 Javascript 的这些缺陷。</p><p>那么一名优秀的、甚至卓越的 前端开发工程师的具备什么条件？<br>首先，优秀的Web前端开发工程师要在知识体系上既要有广度和深度！做到这两点，其实很难。所以很多大公司即使出高薪也很难招聘到理想的前端开发工程师。技术非黑即白，只有对和错，而技巧则见仁见智。<br>在以前，会一点Photoshop和Dreamweaver的操作，就可以制作网页。<br>现在，只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。<br>Web前端开发在产品开发环节中的作用变得越来越重要，而且需要专业的前端工程师才能做好。<br>Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站的界面更好地呈现给用户。</p><p>其次，优秀的Web前端开发工程师应该具备快速学习能力。Web发展的很快，甚至可以说这些技术几乎每天都在变化！如果没有快速学习能力，就跟不上Web发展的步伐。前端工程师必须不断提升自己，不断学习新技术、新模式；仅仅依靠今天的知识无法适应未来。Web的明天与今天必将有天壤之别，而前端工程师的工作就是要搞清楚如何通过自己的Web应用程序来体现这种翻天覆地的变化。<br>说到这里，我想起了一个大师说过的一句话：对于新手来说，新技术就是新技术。<br>对于一个高手来说，新技术不过是就技术的延伸。<br>再者，优秀的前端工程师需要具备良好的沟通能力，因为前端工程师至少都要满足四类客户的需求。<br>1、产品经理。这些是负责策划应用程序的一群人。他们会想出很多新鲜的、奇怪的、甚至是不可是实现的应用。一般来说，产品经理都追求丰富的功能。<br>2、UI设计师。这些人负责应用程序的视觉设计和交互模拟。他们关心的是用户对什么敏感、交互的一贯性以及整体的好用性。一般来说，UI设计师于流畅靓丽、但并不容易实现的用户界面，而且他们经常不满前端工程师造成 1px 的误差。<br>3、项目经理。这些人负责实际地运行和维护应用程序。项目管理的主要关注点，无外乎正常运行时间、应用程序始终正常可用的时间、性能和截止日期。项目经理追求的目标往往是尽量保持事情的简单化，以及不在升级更新时引入新问题。<br>4、最终用户。指的是应用程序的主要消费者。尽管前端工程师不会经常与最终用户打交道，但他们的反馈意见至关重要。最终用户要求最多的就是对个人有用的功能，以及竞争性产品所具备的功能。<br>Yahoo 公司 ，YUI 的开发工程师 Nicholas C. Zakas 认为：<br>前端工程师是计算机科学职业领域中最复杂的一个工种。绝大多数传统的编程思想已经不适用了，为了在多种平台中使用，多种技术都借鉴了大量软科学的知识和理念。成为优秀前端工程师所要具备的专业技术，涉及到广阔而复杂的领域，这些领域又会因为你最终必须服务的各方的介入而变得更加复杂。专业技术可能会引领你进入成为前端工程师的大门，但只有运用该技术创造的应用程序以及你跟他人并肩协同的能力，才会真正让你变得优秀。</p><hr><p>关于书籍：<br>HTML、CSS 类别书籍，都是大同小异，在当当网、卓越网搜索一下很多推荐。如果感觉学的差不多了，可以关注一下《CSS禅意花园》，这个很有影响力。<br>Javascript 的书籍 推荐看老外写的，国内很多 Javascript 书籍的作者对 Javascript 语言了解的都不是很透彻。<br>这里推荐几本 Javascript 书籍：<br>初级读物：<br>《JavaScript高级程序设计》：一本非常完整的经典入门书籍，被誉为JavaScript圣经之一，详解的非常详细，最新版第三版已经发布了，建议购买。<br>《JavaScript王者归来》百度的一个Web开发项目经理写的，作为初学者准备的入门级教程也不错。<br>中级读物：<br>《JavaScript权威指南》：另外一本JavaScript圣经，讲解的也非常详细，属于中级读物，建议购买。<br>《JavaScript.The.Good.Parts》：Yahoo大牛，JavaScript精神领袖Douglas Crockford的大作，虽然才100多页，但是字字珠玑啊！强烈建议阅读。<br>《高性能JavaScript》：《JavaScript高级程序设计》作者Nicholas C. Zakas的又一大作。<br>《Eloquent JavaScript》：这本书才200多页，非常短小，通过几个非常经典的例子（艾米丽姨妈的猫、悲惨的隐士、模拟生态圈、推箱子游戏等等）来介绍JavaScript方方面面的知识和应用方法。<br>高级读物：<br>《JavaScript Patterns 》：书中介绍到了各种经典的模式，如构造函数、单例、工厂等等，值得学习。<br>《Pro.JavaScript.Design.Patterns》：Apress出版社讲解JavaScript设计模式的书，非常不错。<br>《Developing JavaScript Web Applications》：构建富应用的好书，针对MVC模式有较为深入的讲解，同时也对一些流程的库进行了讲解。<br>《Developing Large Web Applications》：不仅有JavaScript方面的介绍，还有CSS、HTML方面的介绍，但是介绍的内容却都非常不错，真正考虑到了一个大型的Web程序下，如何进行JavaScript架构设计，值得一读。<br>要做优秀的前端工程师，还需要继续努力：《高性能网站建设指南》、《Yahoo工程师的网站性能优化的建议》、“YSLOW”性能优化建议、《网站重构》、《Web开发敏捷之道》、“ jQuery 库”、“前端框架”、“HTML5”、“CSS3”。。。 这些都要深入研究！</p><p>万事开头难！如果你能到这个境界，剩下的路自己就可以走下去了。<br>人们常说：不想当裁缝的司机，不是个好厨师。<br>如果单纯只是学习前端编程语言、而不懂后端编程语言（PHP、ASP.NET，JSP、Python），也不能算作是优秀的前端工程师。<br>在成为一个优秀的前端工程师的道路上，充满了汗水和辛劳。</p><pre><code>                                                        —— 王子墨  写于Hong Kong,Kowloon                                                            2012年10月28日 20:18</code></pre><p>摘自：王子墨博客 <a href="http://julying.com/blog/how-to-become-a-good-web-front-end-engineer/" target="_blank" rel="noopener">http://julying.com/blog/how-to-become-a-good-web-front-end-engineer/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《你不知道的javascript》学习笔记-第二部分第二章：this全面解析</title>
      <link href="/2016/08/18/this-quan-mian-jie-xi/"/>
      <url>/2016/08/18/this-quan-mian-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>在第1章中，我们排除了一些对于this的错误理解并且明白了每个函数的this是在调用时被绑定<br>的，完全取决于函数的调用位置（也就是函数的调用方法）。<br><a id="more"></a></p><h1 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h1><p>调用位置：调用位置就是函数在代码中被调用的位置（而<br>不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个this到底引用的是什么？</p><p>分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置<br>就在当前正在执行的函数的前一个调用中。</p><pre><code>function baz() {// 当前调用栈是：baz// 因此， 当前调用位置是全局作用域console.log( &quot;baz&quot; );bar(); // &lt;-- bar的调用位置} function bar() {// 当前调用栈是baz -&gt; bar// 因此， 当前调用位置在baz中console.log( &quot;bar&quot; );foo(); // &lt;-- foo的调用位置} function foo() {// 当前调用栈是baz -&gt; bar -&gt; foo// 因此， 当前调用位置在bar中console.log( &quot;foo&quot; );} baz(); // &lt;-- baz的调用位置</code></pre><blockquote><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但<br>是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法是使用浏览器的调试工具。绝大<br>多数现代桌面浏览器都内置了开发者工具，其中包含JavaScript调试器。就本例来说，你可以在<br>工具中给foo()函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一<br>条debugger;语句</p></blockquote><h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><p>我们来看看在函数的执行过程中调用位置如何决定this的绑定对象。<br>你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条<br>规则，然后解释多条规则都可用时它们的优先级如何排列。</p><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规<br>则时的默认规则。</p><pre><code>function foo() {    //当前调用栈    console.log( this.a );} var a = 2;foo(); // 2  调用位置</code></pre><p>调用foo()时，this.a被解析成了全局变量a。为什么？因为在本例中，函数<br>调用时应用了this的默认绑定，因此this指向全局对象。</p><p><b>在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应<br>    用其他规则。</b><br>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此this会绑定<br>到undefined：</p><pre><code>function foo() {&quot;use strict&quot;;console.log( this.a );} var a = 2;foo(); // TypeError: this is undefined    </code></pre><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不<br>过这种说法可能会造成一些误导</p><pre><code>function foo() {console.log( this.a );} var obj = {a: 2,foo: foo};obj.foo(); // 2</code></pre><p>当foo()被调用时，它的落脚点确实指向obj对象。当函数引用有上下文<br>对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因为调用foo()时this被绑<br>定到obj，因此this.a和obj.a是一样的。<br>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：</p><pre><code>function foo() {console.log( this.a );} var obj2 = {a: 42,foo: foo};var obj1 = {a: 2,obj2: obj2};obj1.obj2.foo(); // 42</code></pre><p>隐式丢失<br>一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑<br>定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。<br>思考下面的代码：</p><pre><code>function foo() {console.log( this.a );} var obj = {a: 2,foo: foo};var bar = obj.foo; // 函数别名！var a = &quot;oops, global&quot;; // a是全局对象的属性bar(); // &quot;oops, global&quot;</code></pre><p>虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一<br>个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><pre><code>function foo() {console.log( this.a );} function doFoo(fn) {// fn其实引用的是foofn(); // &lt;-- 调用位置！} var obj = {a: 2,foo: foo};var a = &quot;oops, global&quot;; // a是全局对象的属性doFoo( obj.foo ); // &quot;oops, global&quot;</code></pre><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子<br>一样。<br>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没<br>有区别</p><pre><code>function foo() {console.log( this.a );} var obj = {a: 2,foo: foo};var a = &quot;oops, global&quot;; // a是全局对象的属性setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;JavaScript环境中内置的setTimeout()函数实现和下面的伪代码类似：&gt;function setTimeout(fn,delay) {// 等待delay毫秒fn(); // &lt;-- 调用位置！&gt;}</code></pre><p>就像我们看到的那样，回调函数丢失this绑定是非常常见的。除此之外，还有一种情况this的行为<br>会出乎我们意料：调用回调函数的函数可能会修改this。在一些流行的JavaScript库中事件处理器<br>常会把回调函数的this强制绑定到触发事件的DOM元素上。这在一些情况下可能很有用，但是有<br>时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。<br>无论是哪种情况，this的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没<br>有办法控制会影响绑定的调用位置。之后我们会介绍如何通过固定this来修复（这里是双关，“修<br>复”和“固定”的英语单词都是fixing）这个问题。</p><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属<br>性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。</p><p>JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使用call(..)<br>和apply(..)方法<br>它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着<br>在调用函数时指定这个this。因为你可以直接指定this的绑定对象，因此我们称之为显式绑定。</p><pre><code>function foo() {console.log( this.a );} var obj = {a:2};foo.call( obj ); // 2</code></pre><p>通过foo.call(..)，我们可以在调用foo时强制把它的this绑定到obj<br>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原<br>始值会被转换成它的对象形式（也就是new String(..)、new Boolean(..)或者new Number(..)）。这通<br>常被称为“装箱”。<br>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题</p><h3 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h3><p>但是显式绑定的一个变种可以解决这个问题。</p><pre><code>function foo() {console.log( this.a );} var obj = {a:2};var bar = function() {foo.call( obj );};bar(); // 2setTimeout( bar, 100 ); // 2// 硬绑定的bar不可能再修改它的thisbar.call( window ); // 2</code></pre><p>我们创建了函数bar()，并在它的内部手动调用<br>了foo.call(obj)，因此强制把foo的this绑定到了obj。无论之后如何调用函数bar，它总会手动<br>在obj上调用foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：</p><pre><code>function foo(something) {console.log( this.a, something );return this.a + something;} var obj = {a:2};var bar = function() {return foo.apply( obj, arguments );};var b = bar( 3 ); // 2 3console.log( b ); // 5</code></pre><h3 id="API调用的“上下文”"><a href="#API调用的“上下文”" class="headerlink" title="API调用的“上下文”"></a>API调用的“上下文”</h3><p>第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选的<br>参数，通常被称为“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this。<br>举例来说：</p><pre><code>function foo(el) {console.log( el, this.id );} var obj = {id: &quot;awesome&quot;};// 调用foo(..)时把this绑定到obj[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome</code></pre><p>这些函数实际上就是通过call(..)或者apply(..)实现了显式绑定，这样你可以少些一些代码。</p><h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类时会调用类中的<br>构造函数。通常的形式是这样的：</p><blockquote><p>something = new MyClass(..);</p></blockquote><p>JavaScript中new的机制实际上和面向类的<br>语言完全不同<br>JavaScript，构造函数只是一些使用new操作符<br>时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一<br>种特殊的函数类型，它们只是被new操作符调用的普通函数而已。</p><p>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的this。</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。<pre><code>function foo(a) {this.a = a;} var bar = new foo(2);console.log( bar.a ); // 2</code></pre>使用new来调用foo(..)时，我们会构造一个新对象并把它绑定到foo(..)调用中的this上。new是最<br>后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1>毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。<br>隐式绑定和显式绑定哪个优先级更高？我们来测试一下：<pre><code>function foo() {console.log( this.a );} var obj1 = {a: 2,foo: foo};var obj2 = {a: 3,foo: foo};obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2</code></pre>可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。</li></ol><p>判断this<br>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来<br>进行判断：</p><ol><li>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。<blockquote><p>var bar = new foo()</p></blockquote></li><li>函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。<blockquote><p>var bar = foo.call(obj2)</p></blockquote></li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。<blockquote><p>var bar = obj1.foo()</p></blockquote></li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<blockquote><p>var bar = foo()</p></blockquote></li></ol><p>就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白this的绑定原理了。不过……<br>凡事总有例外</p><h1 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h1><p>ES6中介绍了一种无法使用这些规<br>则的特殊函数类型：箭头函数。<br>箭头函<br>数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。<br>我们来看看箭头函数的词法作用域：</p><pre><code>function foo() {// 返回一个箭头函数return (a) =&gt; {//this继承自foo()console.log( this.a );};} var obj1 = {a:2};var obj2 = {a:3};var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是3！</code></pre><p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头<br>函数）的this 也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！）</p><p>如果你经常编写this风格的代码，但是绝大部分时候都会使用self = this或者箭头函数来否<br>定this机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误this风格的代码；</li><li>完全采用this风格，在必要时使用bind(..)，尽量避免使用self = this和箭头函数。<br>当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用<br>这两种风格通常会使代码更难维护，并且可能也会更难编写。<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1></li></ol><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以<br>顺序应用下面这四条规则来判断this的绑定对象。</p><ol><li>由new调用？绑定到新创建的对象。</li><li>由call或者apply（或者bind）调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认：在严格模式下绑定到undefined，否则绑定到全局对象。</li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略this绑定，你可以<br>使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。<br>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体<br>来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。这其实和ES6之前代码中<br>的self = this机制一样。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 你不知道的javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《你不知道的javascript》学习笔记-第二部分第一章：关于this</title>
      <link href="/2016/08/17/about-this/"/>
      <url>/2016/08/17/about-this/</url>
      
        <content type="html"><![CDATA[<p>this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数<br>的作用域中。但是即使是非常有经验的JavaScript开发者也很难说清它到底指向什么。<br><a id="more"></a></p><h1 id="为什么要用this"><a href="#为什么要用this" class="headerlink" title="为什么要用this"></a>为什么要用this</h1><pre><code>function identify() {return this.name.toUpperCase();} function speak() {var greeting = &quot;Hello, I&#39;m &quot; + identify.call( this );console.log( greeting );} var me = {name: &quot;Kyle&quot;};var you = {name: &quot;Reader&quot;};identify.call( me ); // KYLEidentify.call( you ); // READERspeak.call( me ); // Hello, 我是KYLEspeak.call( you ); // Hello, 我是READER</code></pre><p>这段代码可以在不同的上下文对象（me和you）中重复使用函数identify()和speak()，不用针对每<br>个对象编写不同版本的函数。<br>如果不使用this，那就需要给identify()和speak()显式传入一个上下文对象。</p><pre><code>function identify(context) {return context.name.toUpperCase();} function speak(context) {var greeting = &quot;Hello, I&#39;m &quot; + identify( context );console.log( greeting );} identify( you ); // READERspeak(me); //Hello, 我是KYLE</code></pre><h1 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h1><h2 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h2><p>我们想要记录一下函数foo被调用的次数，思考一下下面的代码：</p><pre><code>function foo(num) {    console.log( &quot;foo: &quot; + num );    // 记录foo被调用的次数    this.count++;} foo.count = 0;var i;for (i=0; i&lt;10; i++)=&quot;&quot; {=&quot;&quot; if=&quot;&quot; (i=&quot;&quot;&gt; 5) {    foo( i );    }}// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log( foo.count ); // 0 -- WTF?</code></pre><p>console.log语句产生了4条输出，证明foo(..)确实被调用了4次，但是foo.count仍然是0。显然从字<br>面意思来理解this是错误的。<br>执行foo.count = 0时，的确向函数对象foo添加了一个属性count。但是函数内部代码this.count中<br>的this并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。</p><p>遇到这样的问题时，许多开发者并不会深入思考为什么this的行为和预期的不一致，也不会试图<br>回答那些很难解决但却非常重要的问题。他们只会回避这个问题并使用其他方法来达到目的，比<br>如创建另一个带有count属性的对象</p><pre><code>function foo(num) {console.log( &quot;foo: &quot; + num );// 记录foo被调用的次数data.count++;} var data = {count: 0};var i;for (i=0; i&lt;10; i++) {    if (i &gt; 5) {    foo( i );    }}// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log( data.count ); // 4</code></pre><p>从某种角度来说这个方法确实“解决”了问题，但可惜它忽略了真正的问题——无法理解this的含<br>义和工作原理——而是返回舒适区，使用了一种更熟悉的技术：词法作用域。<br>思考一下下面这两个函数：</p><pre><code>function foo() {foo.count = 4; // foo指向它自身} setTimeout( function(){// 匿名（ 没有名字的） 函数无法指向自身}, 10 );</code></pre><p>第一个函数被称为具名函数，在它内部可以使用foo来引用自身。<br>但是在第二个例子中，传入setTimeout(..)的回调函数没有名称标识符（这种函数被称为匿名函<br>数），因此无法从函数内部引用自身</p><p>所以，对于我们的例子来说，另一种解决方法是使用foo标识符替代this来引用函数对象：</p><pre><code>function foo(num) {console.log( &quot;foo: &quot; + num );// 记录foo被调用的次数foo.count++;} foo.count = 0var i;for (i=0; i&lt;10; i++) {if (i &gt; 5) {foo( i );}}// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log( foo.count ); // 4</code></pre><p>然而，这种方法同样回避了this的问题，并且完全依赖于变量foo的词法作用域。<br>另一种方法是强制this指向foo函数对象：</p><pre><code>function foo(num) {console.log( &quot;foo: &quot; + num );// 记录foo被调用的次数// 注意， 在当前的调用方式下（ 参见下方代码） ， this确实指向foothis.count++;} foo.count = 0;var i;for (i=0; i&lt;10; i++) {if (i &gt; 5) {// 使用call(..)可以确保this指向函数对象foo本身foo.call( foo, i );}}// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？console.log( foo.count ); // 4</code></pre><p>这次我们接受了this，没有回避它。如果你仍然感到困惑的话，不用担心，之后我们会详细解释具<br>体的原理。</p><h2 id="它的作用域"><a href="#它的作用域" class="headerlink" title="它的作用域"></a>它的作用域</h2><p>第二种常见的误解是，this指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确<br>的，但是在其他情况下它却是错误的。<br>需要明确的是，this在任何情况下都不指向函数的词法作用域。在JavaScript内部，作用域确实和<br>对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过JavaScript代码访问，它存在于<br>JavaScript引擎内部。<br>思考一下下面的代码，它试图（但是没有成功）跨越边界，使用this来隐式引用函数的词法作用域：</p><pre><code>function foo() {var a = 2;this.bar();} function bar() {console.log( this.a );} foo(); // ReferenceError: a is not defined</code></pre><p>这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实际上它<br>出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感）地展示了this多<br>么容易误导人。<br>首先，这段代码试图通过this.bar()来引用bar()函数。这是绝对不可能成功的，我们之后会解释原<br>因。调用bar()最自然的方法是省略前面的this，直接使用词法引用标识符。<br>此外，编写这段代码的开发者还试图使用this联通foo()和bar()的词法作用域，从而让bar()可以<br>访问foo()作用域里的变量a。这是不可能实现的，你不能使用this来引用一个词法作用域内部的东<br>西。<br>每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</p><h1 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h1><p>之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时<br>的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在<br>哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在<br>函数执行的过程中用到。<br>在下一章我们会学习如何寻找函数的调用位置，从而判断函数在执行过程中会如何绑定this。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于那些没有投入时间学习this机制的JavaScript开发者来说，this的绑定一直是一件非常令人<br>困惑的事。this是非常重要的，但是猜测、尝试并出错和盲目地从Stack Overflow上复制和粘贴答<br>案并不能让你真正理解this的机制。<br>学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，你也许被这样的解<br>释误导过，但其实它们都是错误的。<br>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><b>本文为原创文章，大部分来自于《你不知道的javascript》一书中，转载请注明出处<a href="https://xdlmr.github.io">https://xdlmr.github.io</a></b></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 你不知道的javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《你不知道的javascript》学习笔记—第一部分第五章：作用域闭包</title>
      <link href="/2016/08/14/you-do-not-know-javascript-5/"/>
      <url>/2016/08/14/you-do-not-know-javascript-5/</url>
      
        <content type="html"><![CDATA[<h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><p>闭包并不是一个需要学习新的语法或模式才能使用的工具，它也不是一件必须接受像Luke2一样的原力训练才能使用和掌握的武器。<br>闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。<br>最后你恍然大悟：原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了<br><a id="more"></a></p><h1 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h1><p>下面是直接了当的定义，你需要掌握它才能理解和识别闭包：</p><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>下面用一些代码来解释这个定义。</p><pre><code>function foo() {    var a = 2;    function bar() {      console.log( a ); // 2    }    bar();} foo();</code></pre><p>基于词法作用域的查找规则，函数bar()可以访问外部作用域中的变量a.<br>技术上来讲，也许是闭包。但根据前面的定义，确切地说并不是。<br>从纯学术的角度说，函数bar()具有一个涵盖foo()作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为bar()被封闭在了foo()的作用域中。为什么呢？原因简单明了，因为bar()嵌套在foo()内部。</p><p>通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工<br>作的。</p><p>下面我们来看一段代码，清晰地展示了闭包：</p><pre><code>function foo() {    var a = 2;    function bar() {    console.log( a );    }     return bar;} var baz = foo();baz(); // 2 ———— 朋友， 这就是闭包的效果</code></pre><p>这个例子中，将bar()函数当做一个值类型传递，并将其引用的函数本身当作返回值。</p><p>在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，实际上只是通过<br>不同的标识符引用调用了内部的函数bar()。<br>bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。<br>在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用<br>来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进<br>行回收。<br>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回<br>收。谁在使用这个内部作用域？原来是bar()本身在使用。<br>拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以<br>供bar()在之后任何时间进行引用。<br>bar()依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作<br>用域。<br>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包</p><pre><code>function foo() {    var a = 2;    function baz() {    console.log( a ); // 2    }    bar( baz );}function bar(fn) {    fn(); // 妈妈快看呀， 这就是闭包！}</code></pre><p>把内部函数baz传递给bar，当调用这个内部函数时（现在叫作fn），它涵盖的foo()内部作用域的闭包就可以观察到了，因为它能够访问a。<br>传递函数当然也可以是间接的。</p><pre><code>var fn;function foo() {    var a = 2;    function baz() {        console.log( a );        }     fn = baz; // 将baz分配给全局变量} function bar() {    fn(); // 妈妈快看呀， 这就是闭包！} foo();bar(); // 2</code></pre><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p><p><b>总而言之，闭包的应用有两种情况–函数作为返回值，函数作为参数传递</b></p><h1 id="现在我懂了"><a href="#现在我懂了" class="headerlink" title="现在我懂了"></a>现在我懂了</h1><pre><code>function wait(message) {    setTimeout( function timer() {       console.log( message );    }, 1000 );} wait( &quot;Hello, closure!&quot; );</code></pre><p>将一个内部函数（名为timer）传递给setTimeout(..)。timer具有涵盖wait(..)作用域的闭包，因此<br>还保有对变量message的引用。</p><p>wait(..)执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保有wait(..)作用域的闭<br>包。</p><p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类<br>型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通<br>信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使<br>用闭包！</p><h1 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h1><pre><code>for (var i=1; i&lt;=5; i++) {    setTimeout( function timer() {    console.log( i );    }, i*1000 );}</code></pre><p>这段代码在运行时会以每秒一次的频率输出五次6。<br>事实上，当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被<br>执行，因此会每次输出一个6出来。</p><p>假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域<br>的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭<br>在一个共享的全局作用域中，因此实际上只有一个i。</p><p>第3章介绍过，IIFE会通过声明并立即执行一个函数来创建作用域</p><pre><code>for (var i=1; i&lt;=5; i++) {            (function() {                setTimeout( function timer() {                    console.log( i );                }, i*1000 );            })();        }    </code></pre><p>我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来。</p><p>仔细看一下，我们的IIFE只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。它需要有自己的变量，用来在每个迭代中储存i的值：</p><pre><code>for (var i=1; i&lt;=5; i++) {            (function() {                var j =i                setTimeout( function timer() {                    console.log( j );                }, j*1000 );            })();        }    </code></pre><p>改进代码</p><pre><code>for (var i=1; i&lt;=5; i++) {    (function(j) {        setTimeout( function timer() {            console.log( j );            }, j*1000 );        })( i );    }</code></pre><p>在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域<br>封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p><p><b>重返块作用域</b></p><p>每次迭代我们都需要一个块作用域。第3章介绍了let声明，可以用来劫持块作用域，并且<br>在这个块作用域中声明一个变量。</p><p>本质上这是将一个块转换成一个可以被关闭的作用域。因此</p><pre><code>for (var i=1; i&lt;=5; i++) {    let j = i; // 是的， 闭包的块作用域！    setTimeout( function timer() {        console.log( j );    }, j*1000 );}</code></pre><p>for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><pre><code>for (let i=1; i&lt;=5; i++) {    setTimeout( function timer() {        console.log( i );    }, i*1000 );}</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>闭包就好像从JavaScript中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够<br>到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书<br>写代码的。<br>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生<br>了闭包。<br>如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。</p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><b>本文为原创文章，大部分来自于《你不知道的javascript》一书中，转载请注明出处<a href="https://xdlmr.github.io">https://xdlmr.github.io</a></b></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 你不知道的javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《你不知道的javascript》学习笔记-第一部分第四章：提升</title>
      <link href="/2016/08/13/you-do-not-know-javascript-4/"/>
      <url>/2016/08/13/you-do-not-know-javascript-4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的<br>变量，都将附属于这个作用域。<br>但是作用域同其中的变量声明出现的位置有某种微妙的联系，而这个细节正是我们将要讨论的内<br>容。<br><a id="more"></a></p><h2 id="先有鸡还是先有蛋"><a href="#先有鸡还是先有蛋" class="headerlink" title="先有鸡还是先有蛋"></a>先有鸡还是先有蛋</h2><p>直觉上会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有<br>一种特殊情况会导致这个假设是错误的。<br>考虑以下代码：</p><pre><code>a = 2;var a;console.log( a );</code></pre><p>考虑另外一段代码：</p><pre><code>console.log( a );var a = 2;</code></pre><p>输出来的会是undefined</p><p>看起来我们面对的是一个先有鸡还是先有蛋的问题。到底是声明（蛋）在<br>前，还是赋值（鸡）在前？</p><h2 id="编译器再度来袭"><a href="#编译器再度来袭" class="headerlink" title="编译器再度来袭"></a>编译器再度来袭</h2><p>引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来<br>因此，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。<br>当你看到var a = 2;时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声<br>明：var a;和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执<br>行阶段。<br>我们的第一个代码片段会以如下形式进行处理：</p><pre><code>var a;a = 2;console.log( a );</code></pre><p>其中第一部分是编译，而第二部分是执行。<br>类似地，我们的第二个代码片段实际是按照以下流程处理的：</p><pre><code>var a;console.log( a );a = 2;</code></pre><p>因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上<br>面。这个过程就叫作提升。<br>换句话说，先有蛋（声明）后有鸡（赋值）</p><blockquote><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的<br>顺序，会造成非常严重的破坏。<br>foo();<br>function foo() {<br>   console.log( a ); // undefined<br>   var a = 2;<br>}</p></blockquote><p>foo函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执<br>行。<br>另外值得注意的是，每个作用域都会进行提升操作。这段代码实际上会被理解为下面的形式：</p><pre><code>function foo() {    var a;    console.log( a ); // undefined    a = 2;}foo()</code></pre><p>可以看到，函数声明会被提升，但是函数表达式却不会被提升。</p><pre><code>foo(); // 不是ReferenceError, 而是TypeError!var foo = function bar() {// ...};</code></pre><p>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p><pre><code>foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() {// ...};</code></pre><p>这个代码片段经过提升后，实际上会被理解为以下形式：</p><pre><code>var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() {    var bar = ...self...// ...}</code></pre><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声<br>明的代码中）是函数会首先被提升，然后才是变量。<br>考虑以下代码：</p><pre><code>foo(); // 1var foo;function foo() {    console.log( 1 );} foo = function() {    console.log( 2 );};</code></pre><p>会输出1而不是2！这个代码片段会被引擎理解为如下形式：</p><pre><code>function foo() {    console.log( 1 );} foo(); // 1foo = function() {    console.log( 2 );};</code></pre><p>注意，var foo尽管出现在function foo()…的声明之前，但它是重复的声明（因此被忽略了），因为<br>函数声明会被提升到普通变量之前。</p><p>尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的</p><pre><code>foo(); // 3function foo() {    console.log( 1 );} var foo = function() {    console.log( 2 );};function foo() {    console.log( 3 );}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a和a = 2<br>当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将<br>这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程<br>被称为提升。<br>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。<br>要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危<br>险的问题！</p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p><b>本文为原创文章，大部分来自于《你不知道的javascript》一书中，转载请注明出处<a href="https://xdlmr.github.io">https://xdlmr.github.io</a></b></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 你不知道的javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery中的100个技巧</title>
      <link href="/2016/08/13/100-skill-of-jquery/"/>
      <url>/2016/08/13/100-skill-of-jquery/</url>
      
        <content type="html"><![CDATA[<p>1.当document文档就绪时执行JavaScript代码。我们为什么使用jQuery库呢？原因之一就在于我们可以使jQuery代码在各种不同的浏览器和存在bug的浏览器上完美运行。</p><pre><code> // Different ways to achieve the Document Ready event            // With jQuery            $(document).ready(function(){ /* ... */});            // Short jQuery            $(function(){ /* ... */});            // Without jQuery (doesn&#39;t work in older IE versions)            document.addEventListener(&#39;DOMContentLoaded&#39;,function(){                // Your code goes here            });            // The Trickshot (works everywhere):            r(function(){                alert(&#39;DOM Ready!&#39;);            })            function r(f){/in/.test(document.readyState)?setTimeout(&#39;r(&#39;+f+&#39;)&#39;,9):f()}</code></pre> <a id="more"></a><p> 2.使用route。</p><pre><code>                var route = {                _routes : {},    // The routes will be stored here                add    : function(url, action){                    this._routes[url] = action;                },                run : function(){                    jQuery.each(this._routes, function(pattern){                        if(location.href.match(pattern)){                            // &quot;this&quot; points to the function to be executed                            this();                        }                    });                }            }            // Will execute only on this page:            route.add(&#39;002.html&#39;, function(){                alert(&#39;Hello there!&#39;)            });            route.add(&#39;products.html&#39;, function(){                alert(&quot;this won&#39;t be executed :(&quot;)            });            // You can even use regex-es:            route.add(&#39;.*.html&#39;, function(){                alert(&#39;This is using a regex!&#39;)            });            route.run();</code></pre><p>3.使用JavaScript中的AND技巧。 　　使用&amp;&amp;操作符的特点是如果操作符左边的表达式是false，那么它就不会再判断操作符右边的表达式了。所以：</p><pre><code>// Instead of writing this:if($(&#39;#elem&#39;).length){    // do something}// You can write this:$(&#39;#elem&#39;).length &amp;&amp; log(&quot;doing something&quot;);</code></pre><p>4.is()方法比你想象的更为强大。 下面举几个例子，我们先写一个id为elem的div。js代码如下：</p><pre><code> // First, cache the element into a variable:var elem = $(&#39;#elem&#39;);// Is this a div?elem.is(&#39;div&#39;) &amp;&amp; log(&quot;it&#39;s a div&quot;);// Does it have the bigbox class?elem.is(&#39;.bigbox&#39;) &amp;&amp; log(&quot;it has the bigbox class!&quot;);// Is it visible? (we are hiding it in this example)elem.is(&#39;:not(:visible)&#39;) &amp;&amp; log(&quot;it is hidden!&quot;);// Animatingelem.animate({&#39;width&#39;:200},1);// is it animated?elem.is(&#39;:animated&#39;) &amp;&amp; log(&quot;it is animated!&quot;); </code></pre><p>其中判断是否为动画我觉得非常不错。</p><p>5.判断你的网页一共有多少元素。 通过使用$(“*”).length属性可以判断网页的元素数量。</p><pre><code>// How many elements does your page have?log(&#39;This page has &#39; + $(&#39;*&#39;).length + &#39; elements!&#39;);</code></pre><p>6.使用length()属性很笨重，下面我们使用exist()方法。</p><pre><code>/ Old waylog($(&#39;#elem&#39;).length == 1 ? &quot;exists!&quot; : &quot;doesn&#39;t exist!&quot;);// Trickshot:jQuery.fn.exists = function(){ return this.length &gt; 0; }log($(&#39;#elem&#39;).exists() ? &quot;exists!&quot; : &quot;doesn&#39;t exist!&quot;);</code></pre><p>7.jQuery方法$()实际上是拥有两个参数的，你知道第二个参数的作用吗？</p><pre><code>// Select an element. The second argument is context to limit the search// You can use a selector, jQuery object or dom element$(&#39;li&#39;,&#39;#firstList&#39;).each(function(){    log($(this).html());});log(&#39;-----&#39;);// Create an element. The second argument is an// object with jQuery methods to be calledvar div = $(&#39;&#39;,{    &quot;class&quot;: &quot;bigBlue&quot;,    &quot;css&quot;: {        &quot;background-color&quot;:&quot;purple&quot;    },    &quot;width&quot; : 20,    &quot;height&quot;: 20,    &quot;animate&quot; : {   // You can use any jQuery method as a property!        &quot;width&quot;: 200,        &quot;height&quot;:50    }});div.appendTo(&#39;#result&#39;);</code></pre><p>8.使用jQuery我们可以判断一个链接是否是外部的，并来添加一个icon在非外部链接中，且确定打开方式。 　　这里用到了hostname属性。</p><pre><code>&lt;ul id=&quot;links&quot;&gt;    &lt;li&gt;&lt;a href=&quot;007.html&quot;&gt;The previous tip&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;./009.html&quot;&gt;The next tip&lt;/a&gt;&lt;/li&gt;   &lt;li&gt;&lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;// Loop through all the links$(&#39;#links a&#39;).each(function(){    if(this.hostname != location.hostname){        // The link is external        $(this).append(&#39;&lt;img src=&quot;assets/img/external.png&quot; /&gt;&#39;)               .attr(&#39;target&#39;,&#39;_blank&#39;);    }});</code></pre><p>9.jQuery中的end()方法可以使你的jQuery链更加高效。</p><pre><code>&lt;ul id=&quot;meals&quot;&gt; &lt;li&gt; &lt;ul class=&quot;breakfast&quot;&gt; &lt;li class=&quot;eggs&quot;&gt;No&lt;/li&gt; &lt;li class=&quot;toast&quot;&gt;No&lt;/li&gt; &lt;li class=&quot;juice&quot;&gt;No&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;//var breakfast = $(&#39;#meals .breakfast&#39;);breakfast.find(&#39;.eggs&#39;).text(&#39;Yes&#39;)                      .end() // back to breakfast                      .find(&#39;.toast&#39;).text(&#39;Yes&#39;)                      .end()                      .find(&#39;.juice&#39;).toggleClass(&#39;juice coffee&#39;).text(&#39;Yes&#39;);breakfast.find(&#39;li&#39;).each(function(){    log(this.className + &#39;: &#39; + this.textContent)});</code></pre><p>10.也许你希望你的web 应用感觉更像原生的，那么你可以阻止contextmenu默认事件。</p><pre><code>            // Prevent right clicking on this page            $(function(){                $(document).on(&quot;contextmenu&quot;,function(e){                    e.preventDefault();                });            });</code></pre><p>11.一些站点可能会使你的网页在一个bar下面，即我们所看到在下面的网页是iframe标签中的，我们可以这样解决。</p><pre><code>// Here is how it is used:if(window != window.top){    window.top.location = window.location;}else{    alert(&#39;This page is not displayed in a frame. Open 011.html to see it in action.&#39;);}</code></pre><p>12.你的内联样式表并不是被设置为不可改变的，如下：</p><pre><code>// Make the stylesheet visible and editable$(&#39;#regular-style-block&#39;).css({&#39;display&#39;:&#39;block&#39;, &#39;white-space&#39;:&#39;pre&#39;})                         .attr(&#39;contentEditable&#39;,true);13.有时候我们不希望网页的某一部分内容被选择比如复制粘贴这种事情，我们可以这么做：&lt;p class=&quot;descr&quot;&gt;In certain situations you might want to prevent text on the page from being selectable. Try selecting this text and hit view source to see how it is done.&lt;/p&gt;// Prevent text from being selected            $(function(){                $(&#39;p.descr&#39;).attr(&#39;unselectable&#39;, &#39;on&#39;)                           .css(&#39;user-select&#39;, &#39;none&#39;)                           .on(&#39;selectstart&#39;, false);          });</code></pre><p>这样，内容就不能被选择啦。</p><p>14.从CDN中引入jQuery，这样的方法可以提高我们网站的性能，并且引入最新的版本也是一个不错的主意。 下面会介绍四种不同的方法。</p><pre><code>        &lt;!-- Case 1 - requesting jQuery from the official CDN --&gt;        &lt;script src=&quot;http://code.jquery.com/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;        &lt;!-- Case 2 - requesting jQuery from Google&#39;s CDN (notice the protocol) --&gt;        &lt;!-- &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;        &lt;!-- Case 3 - requesting the latest minor 1.8.x version (only cached for an hour) --&gt;        &lt;!-- &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.10/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;        &lt;!-- Case 4 - requesting the absolute latest jQuery version (use with caution) --&gt;        &lt;!-- &lt;script src=&quot;http://code.jquery.com/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;</code></pre><p>15.保证最小的DOM操作。 　　我们知道js操作DOM是非常浪费资源的，我们可以看看下面的例子。</p><pre><code>CODE// Bad//var elem = $(&#39;#elem&#39;);//for(var i = 0; i &lt; 100; i++){//    elem.append(&#39;element &#39;+i+&#39;&#39;);//}// Goodvar elem = $(&#39;#elem&#39;),    arr = [];for(var i = 0; i &lt; 100; i++){    arr.push(&#39;element &#39;+i+&#39;&#39;);}elem.append(arr.join(&#39;&#39;));</code></pre><p>16.更方便的分解URL。 也许你会使用正则表达式来解析URL，但这绝对不是一种好的方法，我们可以借用a标签来实现它。</p><pre><code>// You want to parse this address into parts:var url = &#39;http://tutorialzine.com/books/jquery-trickshots?trick=12#comments&#39;;// The trickshot:var a = $(&#39;&#39;,{ href: url });log(&#39;Host name: &#39; + a.prop(&#39;hostname&#39;));log(&#39;Path: &#39; + a.prop(&#39;pathname&#39;));log(&#39;Query: &#39; + a.prop(&#39;search&#39;));log(&#39;Protocol: &#39; + a.prop(&#39;protocol&#39;));log(&#39;Hash: &#39; + a.prop(&#39;hash&#39;));</code></pre><p>17.不要害怕使用vanilla.js。 　　jQuery背负的太多，这便是原因，你可以用一般的js。</p><pre><code>// Print the IDs of all LI items$(&#39;#colors li&#39;).each(function(){    // Access the ID directly, instead    // of using jQuery&#39;s $(this).attr(&#39;id&#39;)    log(this.id);});</code></pre><p>18.最优化你的选择器</p><pre><code>// Let&#39;s try some benchmarks!var iterations = 10000, i;timer(&#39;Fancy&#39;);for(i=0; i &lt; iterations; i++){    // This falls back to a SLOW JavaScript dom traversal    $(&#39;#peanutButter div:first&#39;);}timer_result(&#39;Fancy&#39;);timer(&#39;Parent-child&#39;);for(i=0; i &lt; iterations; i++){    // Better, but still slow    $(&#39;#peanutButter div&#39;);}timer_result(&#39;Parent-child&#39;);timer(&#39;Parent-child by class&#39;);for(i=0; i &lt; iterations; i++){    // Some browsers are a bit faster on this one    $(&#39;#peanutButter .jellyTime&#39;)</code></pre><p>19.缓存你的selector。</p><pre><code>// Bad:// $(&#39;#pancakes li&#39;).eq(0).remove();// $(&#39;#pancakes li&#39;).eq(1).remove();// $(&#39;#pancakes li&#39;).eq(2).remove();// Good:var pancakes = $(&#39;#pancakes li&#39;);pancakes.eq(0).remove();pancakes.eq(1).remove();pancakes.eq(2).remove();// Alternatively:// pancakes.eq(0).remove().end()//           .eq(1).remove().end()//           .eq(2).remove().end();</code></pre><p>20.对于重复的函数只定义一次 　　如果你追求代码的更高性能，那么当你设置事件监听程序时必须小心，只定义一次函数然后把它的名字作为事件处理程序传递是不错的方法。</p><pre><code>$(document).ready(function(){    function showMenu(){        alert(&#39;Showing menu!&#39;);        // Doing something complex here    }    $(&#39;#menuButton&#39;).click(showMenu);    $(&#39;#menuLink&#39;).click(showMenu);});</code></pre><p>21.像对待数组一样地对待jQuery对象 　　由于jQuery对象有index值和长度，所以这意味着我们可以把对象当作普通的数组对待。这样也会有更好地性能。</p><pre><code>var arr = $(&#39;li&#39;),    iterations = 100000;timer(&#39;Native Loop&#39;);for(var z=0;z&lt;iterations;z++){    var length = arr.length;    for(var i=0; i &lt; length; i++){      arr[i];    }}timer_result(&#39;Native Loop&#39;);timer(&#39;jQuery Each&#39;);for(z=0;z&lt;iterations;z++){    arr.each(function(i, val) {      this;    });}timer_result(&#39;jQuery Each&#39;);</code></pre><p>22.当做复杂的修改时要分离元素。 　　修改一个dom元素要求网页重绘，这个代价是高昂的，所以如果你想要再提高性能，就可以尝试着当对一个元素进行大量修改时先从页面中分离这个元素，修改完之后再添加到页面。</p><pre><code>// Modifying in placevar elem = $(&#39;#elem&#39;);timer(&#39;In place&#39;);for(i=0; i &lt; iterations; i++){    elem.width(Math.round(100*Math.random()));    elem.height(Math.round(100*Math.random()));}timer_result(&#39;In place&#39;);var parent = elem.parent();// Detaching firsttimer(&#39;Detached&#39;);elem.detach();for(i=0; i &lt; iterations; i++){    elem.width(Math.round(100*Math.random()));    elem.height(Math.round(100*Math.random()));}elem.appendTo(parent);timer_result(&#39;Detached&#39;);</code></pre><p>23.不要一直等待load事件。 　　我们已经习惯了把我们所有的代码都放在ready的事件处理程序中，但是，如果你的html页面很庞大，decument ready恐怕会被延迟了，所以对于一些我们不希望ready后才可以触发的事件可以放在html的head元素中。</p><pre><code>// jQuery is loaded at this point. We can use// event delegation right away to bind events// even before $(document).ready:$(document).on(&#39;click&#39;, &#39;#clickMe&#39;, function(){    alert(&#39;Hit view source and see how this is made&#39;);});$(document).ready(function(){    // This is where you would usually bind event handlers,    // but as we are using delegation, there is no need to.    // $(&#39;#clickMe&#39;).click(function(){ alert(&#39;Hey!&#39;); });});// Note: You should place your script tags at the bottom of the page.// I have included them in the head only to demonstrate that we can bind// events before document ready and before the elements are created.</code></pre><p>24.当使用js给多个元素添加样式时更好的做法是创建一个style元素。 　　我们之前提到过，操作dom是非常慢的，所以当添加多个元素的样式时创建一个style元素并添加到document中是更好的做法。</p><pre><code>&lt;ul id=&quot;testList&quot;&gt; &lt;li&gt;Item&lt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt; &lt;/ul&gt;var style = $(&#39;&lt;style&gt;&#39;);// Try commenting out this line, or change the color:style.text(&#39;#testList li{ color:red;}&#39;);// Placing it before the result section so it affects the elementsstyle.prependTo(&#39;#result&#39;);25.给html元素分配一个名为JS的class。 　　现代的web apps非常的依赖js，这里的一个技巧就是只有当js可用时才能显示特定的元素。看下面的代码。$(document).ready(function(){    $(&#39;html&#39;).addClass(&#39;JS&#39;);});  html.JS #message { display:block; } #message {display:none;}</code></pre><p>26.监听不存在的元素上的事件。 　　jQuery拥有一个先进的事件处理机制，通过on()方法可以监听还不存在的事件。 这是因为on方法可以传递一个元素的子元素选择器作为参数。看下面的例子：</p><pre><code>&lt;ul id=&quot;testList&quot;&gt; &lt;li&gt;Old&lt;/li&gt; &lt;li&gt;Old&lt;/li&gt; &lt;li&gt;Old&lt;/li&gt; &lt;li&gt;Old&lt;/li&gt; &lt;/ul&gt;var list = $(&#39;#testList&#39;);// Binding an event on the list, but listening for events on the li items:list.on(&#39;click&#39;,&#39;li&#39;,function(){    $(this).remove();});// This allows us to create li elements at a later time,// while keeping the functionality in the event listenerlist.append(&#39;&lt;li&gt;New item (click me!)&lt;/li&gt;&#39;);</code></pre><p>27.只使用一次事件监听。 　　有时，我们只需要绑定只运行一次的事件处理程序。那么one()方法是一个不错的选择，通过它你就可以高枕无忧了。</p><pre><code>&lt;button id=&quot;press&quot;&gt;Press me!&lt;/ul&gt;var press = $(&#39;#press&#39;);// There is a method that does exactly that, the one():press.one(&#39;click&#39;,function(){    alert(&#39;This alert will pop up only once&#39;);});// What this method does, is call on() behind the scenes,// with a 1 as the last argument:// press.on(&#39;click&#39;,null,null,function(){alert(&#39;I am the one and only!&#39;);}, 1);</code></pre><p>持续更新中…</p><p>本文转自<a href="http://www.cnblogs.com/zhuzhenwei918/p/6181760.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhuzhenwei918/p/6181760.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jquery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《你不知道的javascript》学习笔记—第一部分第一章：作用域是什么</title>
      <link href="/2016/08/08/zuo-yong-yu-shi-shi-me/"/>
      <url>/2016/08/08/zuo-yong-yu-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li>分词/词法分析（Tokenizing/Lexing）<br>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被<br>称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法<br>单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</li></ul><a id="more"></a><ul><li><p>解析/语法分析（Parsing）<br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的<br>树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。<br>var a = 2;的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个<br>叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节<br>点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。</p></li><li><p>代码生成<br>将AST转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。<br>抛开具体细节，简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来<br>创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。</p></li></ul><h1 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h1><p>学习作用域的方式是将这个过程模拟成几个人物之间的对话</p><h2 id="演员表"><a href="#演员表" class="headerlink" title="演员表"></a>演员表</h2><p>对程序var a = 2;进行处理的过程中的演员；</p><ul><li>引擎<br>从头到尾负责整个JavaScript程序的编译及执行过程。</li><li>编译器<br>引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。</li><li>作用域<br>引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施<br>一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li></ul><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><p>将var a = 2;分解事实上编译器会进行如下处理。</p><ol><li><p>遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。<br>如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一<br>个新的变量，并命名为a。</p></li><li><p>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎<br>运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果否，引擎就会<br>使用这个变量；如果不是，引擎会继续查找该变量（查看1.3节）。如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！</p></li></ol><p>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没<br>有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p><h2 id="编译器有话说"><a href="#编译器有话说" class="headerlink" title="编译器有话说"></a>编译器有话说</h2><p>在我们的例子中，引擎会为变量a进行LHS查询。另外一个查找的类型叫作RHS，“L”和“R”的含义，它们分别代表左侧和右侧。是一个赋值操作的左侧和右侧。换句话说，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。<br>讲得更准确一点，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量<br>的容器本身，从而可以对其赋值。</p><p>console.log( a );对a的引用是一个RHS引用，a = 2;这里对a的引用则是LHS引用</p><h2 id="引擎和作用域的对话"><a href="#引擎和作用域的对话" class="headerlink" title="引擎和作用域的对话"></a>引擎和作用域的对话</h2><blockquote><p>function foo(a) {<br>console.log( a ); // 2<br>}<br>foo( 2 );<br>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。<br>引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？<br>作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎：哥们太够意思了！好吧，我来执行一下foo。<br>引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？<br>作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。<br>引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。<br>引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？<br>作用域：咱俩谁跟谁啊，再说我就是干这个的。这个我也有，console是个内置对象。给你。<br>引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。<br>引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。<br>作用域：放心吧，这个变量没有变动过，拿走，不谢。<br>引擎：真棒。我来把a的值，也就是2，传递进log(..)。</p></blockquote><h2 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h2><p>作用域是根据名称查找变量的一套规则,当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作<br>用域（也就是全局作用域）为止。<br>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一<br>级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行<br>赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。<br>赋值操作符会导致LHS查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值<br>操作。<br>JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2这样的声明会被分<br>解成两个独立的步骤：</p><ol><li>首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li><li>接下来，a = 2会查询（LHS查询）变量a并对其进行赋值。<br>LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识<br>符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局<br>作用域（顶层），无论找到或没找到都将停止。</li></ol><p>不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个<br>全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常<br>（严格模式下）。</p><h1 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h1><p><b>本文为原创文章，大部分来自于《你不知道的javascript》一书中，转载请注明出处<a href="https://xdlmr.github.io">https://xdlmr.github.io</a></b></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 你不知道的javascript </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
